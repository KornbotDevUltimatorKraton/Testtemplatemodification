<!---Author: Mr.Chanapai Chuadchum-->
<!--Project: Automated product design ProdX--> 
<!--Date of development 10/05/2020-->
<!DOCTYPE html>
<html lang="en">
<head>
   <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta charset="UTF-8">
    <title>idatabots product development</title>    <!--Product design generatorr-->
    <meta charset="utf-8">
    <link type="text/css" rel="stylesheet" href="static/main.css">  <!--Loading the background .css function-->
  
    <!--<input id="myInput" type="file" style="visibility:hidden" /> --Insert the input function of the file dialogue-->

    <!--Save will be another function to add into the sytem -->
    <!--Setting the body style of the scene --->
    <!--Babylon resizing using the canvas-->
    <style>

    body { overflow: hidden; width: 100%; height: 100%; margin: 0; fill: 0; }
    canvas {display:block;}    
       babylon {
            width: 800px;
            height: 800px;
        }
     canvas {width: 100%; height: 150%;}
     #my-gui-container {
     position: absolute;
     top: 70px;
     left: 10px;
     z-index: 10;
   } 
   #my-guir-container {
     position: absolute;
     top: 500px;
     left: 10px;
     z-index: 10;
   } 
   #renderCanvas {
            width   : 100%;
            height  : 150%;
            touch-action: none;
   }

   </style> 
   </head>
    <body>
       <canvas id="renderCanvas"></canvas>
      <!-- <input type="file" name="model" id="model-input"> -->

     <!--  
       <div id="upload-model">
         <ul id="model-list"></ul>
         <input type="file" name="model" id="model-input">
      </div>
   -->
      <babylon extends="none">

      </babylon>
  
    <!--  <div id="google_translate_element"></div> -->
     
      <script  src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r123/three.js"> </script>  <!--Threejs library load library-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r123/three.min.js"> </script> <!--Threemin.js for the compact light weight 3d modelling loader-->
      <script src="/static/OrbitControls.js"> </script> <!--Orbit control function -->
    <script src="/static/GLTFLoader.js"> </script> <!--GLTF loader function for the model loader-->
    <script src="/static/ColladaLoader.js"> </script> <!---Collada for the model loader-->
    <script src="/static/litegraph.js"></script>  <!---The Visual programming lite graph generatot-->
    <script src="/static/litegraph-editor.js"></script> <!--Visual programming lite graph-->
    <script src="/static/physi.js"> </script> <!--Physics JS for physics function on the system -->
    <!--Adding the status of the FPS for showing the function of the frame rate of model animation-->
    <script src="/static/stats.min.js"> </script>  <!--Showung the FPS -->
    <!--<script src="/static/script.js"> </script> Speech synthesis and Speech recognition capability for the threejs This function will be able to control the interface from the dat.gui.js-->
    <script src="/static/ammo.js"> </script> <!--Ammo js for the physics animation-->
    <script src="/static/ammo.min.js"> </script> 
    <script src="/static/uuid.js"></script>
    <script src="/static/uuid.min.js"></script>
     <!--Adding the the library of maze environment -->
    <script src="static/array.js"></script>
    <script src="static/cell.js"></script>
    <script src="static/graph.js"></script>
    <script src="static/maze.js"></script>
    <script src="static/mazeGenerator.js"></script>
    <script src="static/underscore-min.js"></script>
    <script src="static/babylon.js"></script>  <!--Alternative Webgl for bone animation function-->
    <script src ="static/babylonjs.loaders.min.js"></script>
    <script src ="static/pep.js"></script>    
    <script src = "static/babylon.max.js"></script>
    <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/libktx.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
   <!--- <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>-->
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script> <!-- min library -->    
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="static/babylon.max.js"></script>
    <script src="static/babylon.viewer.js"></script> 
    <script src="static/environmentSpecular.env"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script> 
    <!--Get the socket io library for the 3d assess share from the 3d loader-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js"></script>
    <!---GLTF loader for babylon-->
    <script src ="static/babylon.glTF2FileLoader.js"></script>
        
    <!--<script src="/static/rete/rete.config.js"> </script>-->
    <script type="text/javascript" src="static/dat.gui.min.js"></script>  
    <canvas id="renderCanvas"></canvas>
    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->
    <script type="text/javascript">
    
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    alert("Please select the meshes part beforce select the components for your product");
    alert("To using in full mode please Sign Up / Login and pay for the services");
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
           // google translator 
     function googleTranslateElementInit() {
             new google.translate.TranslateElement({pageLanguage: 'en'}, 'google_translate_element');
}
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                   // File loader for the model loader function 
      var url; 
      var blob; 
      window.addEventListener('DOMContentLoaded', function(){          
            // get the canvas DOM element
            var canvas = document.getElementById('renderCanvas');

            // load the 3D engine
            var engine = new BABYLON.Engine(canvas, true);

            // createScene function that creates and return the scene
            var createScene = function(){
                // create a basic BJS Scene object
                var scene = new BABYLON.Scene(engine);

                // create a FreeCamera, and set its position to (x:0, y:5, z:-10)
                var camera = new BABYLON.ArcRotateCamera("camera", 4.712, 1.571, 2, BABYLON.Vector3.Zero(), scene);
                     camera.attachControl(scene.getEngine().getRenderingCanvas());
                     camera.minZ = 0.1;
                     camera.maxZ = 1000;
                     camera.lowerRadiusLimit = 0.1;
                     camera.upperRadiusLimit = 5;
                     camera.wheelPrecision = 100;
                     camera.attachControl(canvas, true);
         
                // create a basic light, aiming 0,1,0 - meaning, to the sky
                var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(-20,-30,-50), scene);

                // create a built-in "sphere" shape; its constructor takes 6 params: name, segment, diameter, scene, updatable, sideOrientation 
                //var sphere = BABYLON.Mesh.CreateSphere('sphere1', 16, 2, scene);
                
                // move the sphere upward 1/2 of its height
                //sphere.position.y = 1;
                /*
                BABYLON.SceneLoader.LoadAssetContainer("static/", "idatabots"+".gltf", scene, function (container) {
                  var meshes = container.meshes;
                  var materials = container.materials;
                       
                   container.addAllToScene();
                });
                */
                  BABYLON.SceneLoader.ImportMesh("","static/" ,"idatabots"+".gltf", scene, function (meshes, particleSystems, skeletons) {
                  var model = meshes[0];  // Get the model Mesh part
                   // Setting the rotation of the logo 
                  model.position.x = -0.5;
                  model.position.z = -0.8; 
                  model.rotation.z = Math.PI*0.25; //Model mesh roation 
                  model.rotation = new BABYLON.Vector3(Math.PI +0.2, Math.PI + 0.5, Math.PI); // Get the model rotation for the position control in the function 
                     
                  var angle = 0;
                  scene.registerBeforeRender(function(){
                  model.rotation.y = angle;
                  angle +=0.01;  
                 });
               });
                // change background color
                scene.clearColor = new BABYLON.Color3(.6,.6,.6);

                // create a built-in "ground" shape;
               // var ground = BABYLON.Mesh.CreateGround('ground1', 6, 6, 2, scene);

                // return the created scene
                return scene;
            }

            // call the createScene function
            var scene = createScene();

            // run the render loop
            engine.runRenderLoop(function(){
                scene.render();
            });

            // the canvas/window resize event handler
            window.addEventListener('resize', function(){
                engine.resize();
            });

            // not passing any url since it defaults to trying to connect
            // to the host that serves the page.  
            //Animation
           /*
            var socket = io();
            
            document.getElementById("model-input").addEventListener('change',(e) => {
                e.preventDefault(); // prevents page reloading
                const file = e.target.files[0];
                const fileData = {
                  name: file.name,
                  data: file
                };
                const fileExtension = getFileExtension(file.name)
                socket.emit('file uploaded', fileData);
                addModelNameToList(file.name)
                addModelToScene(file, fileExtension, scene)
                console.log(file.name); // Get the file name display at the console  
                console.log(fileData); // Get the file data 
                return false;
            });

            socket.on('file uploaded', function(filedata){
              addModelNameToList(filedata.name)
              addModelToScene(filedata.data, getFileExtension(filedata.name), scene)
            });


            function getFileExtension(fileName) {
              return '.' + fileName.split('.')[1]
            }

            function addModelNameToList(modelName) {
              const fileNameElement = document.createElement("li");
              fileNameElement.textContent = modelName
              document.getElementById("model-list").append(fileNameElement);
            }

            function addModelToScene(file, fileExtension, scene) {
              scene.meshes.forEach(mesh => {
                mesh.dispose();
              });
              var blob = new Blob([file]);
              var url = URL.createObjectURL(blob);
              BABYLON.SceneLoader.Append("", url, scene, function () { 
                scene.createDefaultCamera(true, true, true);
                }, undefined, undefined, fileExtension);
              }
              */
            });
         
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                       //Scene parameters 
   // global variables
   var renderer;
   var scene;
   var camera;
   var control;
   var controls;  
   var stats;
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                 // FPS status fuction 
         var stats = new Stats();
			stats.showPanel( 1 );
			document.body.appendChild( stats.dom );

			
			function animate() {

				var time = performance.now() / 1000;

  
				stats.begin();
				stats.end();

				requestAnimationFrame( animate );

			}

			animate();

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // Export json code array 
   var comvis = new Array(); // Array computer vision 
   var Allcodegen = new Array(); //code array generator 
   //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // Folder dialogue loader
   var params = {          
    loadFile : function() { 
            //document.getElementById('model-input').click();  // Load the model into the web with the dialogue file 
            window.open("https://idatabots.com/uploadfile"); //upload file into the server and analysing the parts list 
             
            
   }
};
   // Save file of the client model 
   var  savefile = {
      saveFile:function(){
            document.getElementById('model-input').click();
            
   }
};
   //Save as the file in the path where the user want to save as 
   var saveas = {
      saveAs: function(){
    
           document.getElementById('model-input').click(); // Linking with the element by id of the clicked input from the dat.gui button 
      }  
   };

       // Circuit marker function for the specific circuit generator display the circuit 
   var circuitmarker = {add:function(){ 
         // One time click recall the function to get the data from the requirement from the user to using in the algorithm to classify the data of the circuit and module
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
         // first Request the joint motion controller of the robots or the devices machine first 
    
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      //Second get the shape area and the data of the joint parts then analyse the area of the pcb 


      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      //Third get the function of the pcb on the joint and specification for the calculating the possibilty for choosing the right part for the mcu and motor driver to suit that area
      
      
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   }};
   
   var mcusrecord = [];
   var Microcom = "";
   var icrecord = []; 
   var ICcom = "";
   var imagerecord = []; 
   var Imagecom = "";
   var compiterecord = []; 
   var Computecom = ""; 
   var senserecord = []; 
   var Sensecom = ""; 
   var acousrecord = [];
   var Acouscom = "";
   var amprecorder = [];  
   var Ampcom = ""; 
   var navirecorder = []; 
   var Navicom = ""; 
   var cellularrecorder = []; 
   var Cellucom = "";
   var batteryrecorder = []; 
   var Powercom = ""; 
   var bmsrecoreder = []; 
   var BMScom = "";
   var n1 = "";
   var n2 = ""; 
   var n3 = ""; 
   var n4 = "";
   var n5 = "";
   var n6 = "";
   var nmc1 = ""; 
   var nmc2 = "";
   var nmc3 = "";
   var nmc4 = "";
   var inputmcu;
   var inputsense;
   var sensorparts;
   var sensorSpecs; 
   var inputic;
   var inputimagesensor;
   var inputcompute;
   var inputAcoustic;
   var inputamp;
   var inputnavi;
   var inputBMS;
   var inputBattery;
    
   
   var Neucleo32data = ""; 
   var  Neucleo64data = "";
   var Neucleo144data = "";  
   var GenericF4data = "";
   var modelmcus,modelacous,modelcom,modelsense,modelimage,modelactuator,modelacousamp,modelnavigation,modelcellu,modelbattery,modelbms;
   var removepartsmcu = {add:function(){
       //Alert the part removed from the list of the function generated from the mesh selection 
      alert("Removed mesh functiongen"); 
       //Get the remove function to working on the mesh remove    
   }};

   const paramsinput = {
        Amount: "",   // add the number of the text in here for generate multiple meshes
        Vin: "",
        Vout: "", 
        Iin: "", 
        Iout: "", 
        Ichrg: "",
        maxvolt: "",
        minvolt: "", 
        Amp: "mA",  // Unit setting configureble  
        db: "", 
        w: "", 
   }
   var ThreeDprinter = {add:function(){
        // Add the G-code generator here 
        console.log("Generating G-code file ......."); //Generating the g-code file
        alert("Generating G-code file ......."); //Alert the g-code generator for the json file function 
      }};
   var WilessThreeDprinter = {add:function(){
       // Add the wireless 3d printer function
       // Sending the command wirlessly over the ssh function
       console.log("Sending the G-code command through wireless now uploading......");
       alert("Sending the G-code command through wireless now uploading......");

      }};
   var Pickandplacemachine = {add:function(){
       // G-code for the pick and place machine for assembly the pcb board with the smd components
      console.log("Generating the G-code for pick and place machine......"); 
      alert("Generating the G-code for pick and place machine......"); 
   }};
   var AssemblyArm = {add:function(){
      // Assembly arm for the parts assembly process control automation function 
      console.log("Generating the file for the assembly arm .........");
      alert("Generating the file for the assembly arm .........");  
   }};
   //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   //Button for display the visual programming of the product with pre-programming block function  for client from slected parameter and function from the gui 
   var VisualPro = {           
    add:function(){
            //Convert JSON Array to string.
         var json = JSON.stringify(comvis);
         //Convert JSON string to BLOB.
         json = [json];
         var blob1 = new Blob(json, { type: "application/json;charset=utf-8" });
         //Check the Browser.
         var isIE = false || !!document.documentMode; 
         if (isIE) {
         window.navigator.msSaveBlob(blob1, "codeconfiggen.json");
         } else {
         var url = window.URL || window.webkitURL;
         link = url.createObjectURL(blob1);
         var a = document.createElement("a");
         a.download = "codeconfiggen.json";
         a.href = link;
         document.body.appendChild(a);
         a.click();
         document.body.removeChild(a);

}

   }
}

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
               // Setting for the Model animation motion control set 
   Modelmotionset = {
     Rotateshow: false, // Show the rotation of the model to display the body around
     Rotatingcamera: false, // Rotate the camera around the model instead of the rotate model      
     Pointcloud: false // Adding the lidar module into the process to detect the object 

   }; 
   //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                     //Specificatoin data
      
   Visionparameters = {
    objectdetect: false,
    objectrecognition:false, 
    facerecognition: false, 
    posedetection: false,
    poserecognition: false   
   };

   var projectname = function(){   
      // Add the project name in the web for generating file and naming the project on the web 
      this.projectname = ""; // project name file input 
      this.partsnaming = ""; // part naming input 

   };  
   //Code Generator function on the vision system 
   var Computevision = function(){
      this.Objectdetect = true; //The setting value True in the function of the object detection 
      this.Objectrecog = true; //The setting value True on the function of the object recognition     
      this.Facerecog = true; //The setting value True in the function of the facerecognition 
      this.Posedetect = true; //The setting value True in the function of the posedetection function   
      this.Poserecog = true; // The setting value True in the function of the pose recognition  
   }
   //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      // Function of the text display on the system to display the whole control function 
   var FizzyText  = function() {
      this.message = ''; 
      
      //console.log("Materials list data");
   };
   //function of the serial baudrate selection 
   var Serialbaudrate = function(){
      this.message = '';
      console.log(String(this.message)); // Serial bus list data
      //console.log("Serial bus data") 
   };
   //function of the CAN bus baudrate selection
   var CANBus = function(){
      this.message = '';
      console.log(String(this.message)); // CANBUS list data 
      //console.log("CAN BUS data");
   };
   //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     // Function Physical analysis   
   var  TerrainAdjust = function(){
        this.message = '';
        this.opacity =  0.1; // Setting the function of the friction variable 
        this.roughness = 0.1; // Setting the roughness of the terrain function 
        this.temperature = 1; // Setting the temerature of the environment to calculate in the material and handeling function of the model base simulation 
        this.lux = 1; // Maximum lux value at the day light function for testing in the robotic vision simulation function 
        this.gravity  = 0.981; // Gravity value of the area or planet data 
        this.Density =  0.1; // Density of the materials 
      };
   //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // Materials Color and skin control 
   var Materialscontrol = function(){
       this.message = '';  // Control the materials color and skin function for the product and add options function into the system 
       this.light = 0.1;  // Control the light on the materials function 
       this.matprop = ''; // Material property from the materials selection function  
       this.Opticprop = 0.1; // Control the shining of the materials skin 
       this.Densitys = 0.1;
       this.color0 = "#ff9966"; // control the color of the materials function 
       this.color1 = "#336699"; // Control the color of the materials color for mixing in the skin system 
       this.roughness = 0.0; // Get the rpughtness of the materials specification  
   }
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
           // Onboard specification function 
   var Pcboption = function(){
     this.layers = ''; //Setting the pcb layer data 
     this.colors = ''; //Setting the colors function data
     this.Red = '#d4492c'; // Setting the color red 
     this.Green = '#409b2e'; // Setting the color green 
     this.Yellow = '#f7f153'; //Setting the color yello 
     this.Blue = '#55a2f0'; // Setting the color blue 
     this.White = '#f7f7f7'; // Setting the color white 
     this.Black = '#000000'; // Setting the color black 
     this.materials = ''; // Setting the materials  

   }
      // Computer onboard the system linux sbc for the robotics or the devices cloud adge computing system 
  var ComputerOnboard = function(){
     this.sbcspect = '';  // SBC specifications SBC{Spects:Schematics} Get the opensource schematics from the web or cloud database access in the options 
     // List of the specification will be scrap from the web automaticly 
     this.harshenv = ''; // harsh environment SBC  {Specs:Schematics} Get the opensource schematics from the web or cloud database access in the options
     this.militarySpec = ''; // Military spec SBC  {Specs:Schematics} Get the opensource schemtics from the web or cloud database accsess in the options 
     this.SpaceSpec = ''; // Space spec Spec SBC   {Specs:Schematics} Get the opensource schemtics from the web or cloud database accsess in the options 
  }
   //Sensors and Transccer function 
  var Transducer = function(){
       this.Sensorstype = ''; // Get the sensors type data 
       this.Sensorfunction = ''; //Get the sensor function tell what sensors do 
       this.Sensorinterfacecommunication = ''; //Sensor communication selection such as UART ,I2C ,SPI ,ETHER-CAT,
       
  }
  
   //Microcontroller onboard specification for the driver and serial communication function of the actuator to the onboard computer 
  var Microcontroller  = function(){
     this.Neucleo144list = ''; // Get the list of micro controller data 
     this.Neucleo64list = ''; // Get the Neucleo64 list 
     this.Neucleo32list = ''; // Get the Neucleo32 list
     this.GenericF0list = ""; // Get the Generic F0 list 
     this.GenericF1list = ''; // Get the Generic F1 list  
     this.GenericF4list = ''; // Get the generic F4 list 
     this.MCUname = ''; // Get the micro controller name 
     this.pins = ''; // Collecting the pins map function of the microcontroller    
     this.pinsfunction = '';
     this.communication = ''; //Communication type 
     this.powerconfiquretion = ''; // Collect the power comsumption of the microcontroller
     this.communicationprotocol = ''; //Collect the protocol of the microcontroller 
  } 
  
  //Actuators driver function    
  var ActuatorsDive = function(){
   this.Sensorfeedback = ''; //Sensors feed back get the feed back to the query function 
   this.Motortype = ''; // Select the motor type for complete the specification of the mechanics input from the model 
   this.MotorDrive = ''; // Select the motor driver from the database and specification input on each mechanical and specification require
   this.Statussense = ''; // Select the status sensor for reading the value back from the motor to see the functionallity of the motor 
  }
  // Listed the part of the Kinamatic control part of leg and arm robot 
  var Kinematicactuators = function(){
   this.kinematicsjoint = ''; // Get the part joint name to listed variableinto the code 
   this.Materials = ''; // Get the materials part of the robotics for calculation involve with the kinmatic physics simulation control   
   this.positionX = 0; // Get the position of the mesh X file materials 
   this.positionY = 0; // Get the position of the mesh Y file materials 
   this.positionZ = 0; // Get the position of the mesh Z file materials
}
 // Battery specification data 
 var Batteryactive = function(){
    this.batterylistact = ''; //Get the battery list data  
    this.batteryChem = ''; // Get the chemical type of the battery 
    this.batterybms = ''; // Get the battery bms type   
 }
var Assetlistdemo = function(){
    this.assetlist = ''; // Get the asset list of the  model to find the joint and generate the pcb position to atach the board on the model 
}

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      //Scene loader for the multiple model type loader 

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                   // Scene Generator function to control the model and environment scene 
   var scene = { add:function(){

      console.log("Scene generate from babylonjs");
      // Adding the scene and mesh from this button and adjust every thing via here 
      /*
      var scene = new THREE.Scene();
      scene.background = new THREE.Color(0xa0a0a0);
      scene.fog= new THREE.Fog(0xa0a0a0);
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );
      var geometry = new THREE.BoxGeometry();
      var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
      var cube = new THREE.Mesh( geometry, material );  
      scene.add( cube );
      camera.position.z = 5; 
      var animate = function () {
				requestAnimationFrame( animate );

				cube.rotation.x += 0.01;
				cube.rotation.y += 0.01;

				renderer.render( scene, camera );
			};
         animate();
         */
   }};
    // plane terrain for the scene function 
   var Plane = {add:function Planefunc(Environmentparameters){
         // Create the 3d plane environment function 
          // In the control mode will using the 
         console.log("Generated plane by babylonjs"); // plane generated by babylonjs
      /*
      var controls ; // Setting the controls of the orbit variable 
      var scene = new THREE.Scene();
      scene.background = new THREE.Color(0xa0a0a0);
      scene.fog= new THREE.Fog(0xa0a0a0);
      var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
      // Add controls 
      /*
      var controls = new THREE.OrbitControls( camera, renderer.domElement );
      controls.addEventListener( 'change', function(){
      renderer.render(scene,camera); // re-render if controls move/zoom 
      }); 
      controls.enableZoom = true; 
      
      var renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
      document.body.appendChild( renderer.domElement );
      camera.position.z = 5; 
      var axes = new THREE.AxesHelper(20);  //Axes control 
      scene.add(axes); 
      var planeGeometry =  new THREE.PlaneGeometry(60,20); 
      var planeMaterials = new THREE.MeshBasicMaterial({color: 0xcccccc});
      var plane = new THREE.Mesh(planeGeometry,planeMaterials); 
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            //Grid control parameters  
      var size = 70;
      var divisions = 70;
      var gridHelper = new THREE.GridHelper( size, divisions );
      scene.add( gridHelper );
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
         //Ambient light control 
      var light = new THREE.AmbientLight( 0x404040 ); // soft white light
      scene.add( light ); 
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
               // Spot light for the model display control function 
      var spotLight = new THREE.SpotLight(0xffffff);  // Color spot light 
      spotLight.position.set(-40,60,-10);  // Spotlight setting
      spotLight.castShadow = true; 
      scene.add(spotLight); // spotlight function   
       
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        // Orbit control function 
      
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
         // Plane control axis parameters   
      plane.rotation.x = -0.5*Math.PI; // Math control the rotation by input slider function or using the Or 
      plane.position.y = 15; // position of the y axis 
      plane.position.z = 0;  // position of the z axis 
      //scene.add(plane);  // Add plane into the scene  
      camera.position.x = -30;  //plane at x axis 
      camera.position.y = 40;  // plane at y axis 
      camera.position.z = 30;  // plane at the z axis 
      
     
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
          // Add the object sphere for testing the function 
      var sphereGeometry = new THREE.SphereGeometry(20,50,50); 
      var sphereMaterial = new THREE.MeshBasicMaterial({color: 0x7777ff,wireframe: true}); 
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        //3d model added into the plane 3d simulation 
      var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial); 
      sphere.position.x = 20; 
      sphere.position.y = 20;
      sphere.position.z = 2; 
      sphere.castShadow = true;
      scene.add(sphere); // Adding the sphere model into the grid plane geometry
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      camera.lookAt(scene.position); //plane at the position
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
          //Orbit control function 
      var controls = new THREE.OrbitControls( camera, renderer.domElement );
      controls.addEventListener( 'change', render ); //Rendering require the function below to make the orbit control working 
      
     
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 
          // FBX and GLTF loader function 
      /*
      let loader = new THREE.GLTFLoader();
      loader.load('static/assets/scene.gltf', function(gltf){
      Model = gltf.scene.children[0];
      Model.scale.set(0.5,0.5,0.5);
      scene.add(gltf.scene);
      
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  
      function render() {
      renderer.render( scene, camera ); // Screne function 
      renderer.shadowMapEnabled = true; 
      }
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      */
   }};
   // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        // Electronics store parts list search on the web 
     var digikey = {add:function(){ 
          
           window.open("https://www.digikey.com/products/en"); //Open new window for digikey part list search function this function will be able to link with automated search with selenium and searchbot automation 
     }}; 
        // Linking function into the manufacturere 
   
     var jlcpcb = { add:function(){
                 
                window.open("https://cart.jlcpcb.com/quote?orderType=1&stencilLayer=2"); // PCB layour manufacturing function   
            }    
         };   // Linking as the button
     var jlcsmt = { add:function(){

               window.open("https://cart.jlcpcb.com/quote?orderType=1");   // SMT Manufacturing 
     
        }
     };  
     var loadfile = {add:function(){
              window.open("https://idatabots.com/uploadfile"); //upload file into the server and analysing the parts list 
                    
     }
   };
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
       
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
         // Firmware uploader 
    var Serialfirmware = { add:function(){
        // Add the serial firmware in here for the plugin trigger extentsion lanuch 
      window.open(""); // access the link of the plugin to install into the web for serial communication extension function  

    }};  // Add the function in there 
    var Canfirmware = { add:function(){      

    }};  // Add the function in there 
   
  
    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
       // Create the checkbox list variables  
   controllers = []; 
   //var Opticalfunction =  {'Face recognition':flase}; //Face recognition function  
  window.onload = function() {
  var gui = new dat.GUI();  // Setting the gui function 
  
  var text = {
  message: 'dat.gui',
  speed: 0.8,
  displayOutline: false,
};
var compo = document.querySelector("#Componentsdata");
var compodota = document.querySelector("#Comdata");
var microdataset = document.querySelector('#Microset');
var microdatset  = document.querySelector('#Microdatset');
var ICdataset = document.querySelector('#ICdat');
var ICdatset  = document.querySelector('#ICdatset');  
var funcdataset = document.querySelector('#funcdat');
var funcdatset  = document.querySelector('#funcdatset');
var Imagedataset = document.querySelector('#Imagedat');
var Imagedatset  = document.querySelector('#Imagedatset');
var Acousdataset = document.querySelector('#Acousdat');
var Acousdatset  = document.querySelector('#Acousdatset');
var Sensedataset = document.querySelector('#Sensedat');
var Sensordatapart = document.querySelector('#Sensorpartdat');
var SensorSpecpart = document.querySelector('#SensorSpecspart'); // Sensor part selection 
var Sensecompin = document.querySelector('#Sensorpinscom');
var Sensedatset  = document.querySelector('#Sensedatset');
var Computedataset = document.querySelector('#Computedat');
var Computedatset  = document.querySelector('#Computedatset');
var Navidataset = document.querySelector('#Navidat');
var Navidatset  = document.querySelector('#Navidatset');
var Ampdataset = document.querySelector('#Ampdat');
var Ampdatset  = document.querySelector('#Ampdatset');
var Materialsdataset = document.querySelector('#Materialsdat');
var Materialsdatset  = document.querySelector('#Materialsdatset');
var Batterydataset = document.querySelector('#Baterydat');
var Batterydatsets  = document.querySelector('#Batterydatsetr');
var BMSdataset = document.querySelector('#BMSdat');
var BMSdatset  = document.querySelector('#BMSdatset');
var Celludataset = document.querySelector('#Celludat');
var Celludatset  = document.querySelector('#Celludatset');
var Neucle32 = document.querySelector('#Neucle32');
var Neucle64 = document.querySelector('#Neucle64');
var Neucle144 = document.querySelector('#Neucle144');
var GenericF0 = document.querySelector('#GenericF0');  
var GenericF1 = document.querySelector('#GenericF1'); 
var GenericF3 = document.querySelector('#GenericF3');
var GenericF4 = document.querySelector('#GenericF4');
var microlistdata;
var Componentsfunction = function(){
      this.functionapp = '';  // Get the function from the app to list the application functoin setting in the parts 
      this.messages =''; // Name the part 
      this.positioninput = '';  // Position input from the model 
      this.microdata = ''; // Get the microcontroller data 
      this.ic = ''; // Get the ic data from the list request ajax 
      this.materials = ''; // Get the materials data request ajax with the property in the json 
      this.Imagesensor = ''; // Get the image sensor data request ajax 
      this.Acousticsense  = ''; // Get the acoustic sensor list 
      this.AcousticAmp = ''; // Get the Acoustic amplifier ic data in the list request from ajax 
      this.Sensearray = ''; //Get the sensers arraya request ajax data 
      this.Sensorpartsdata = ''; // Get the sensers array data for diferent type of the sensor 
      this.SenseSpec = ''; // Getting the sensor specification and communication function 
      this.SenseCommunic = ''; //Getting the sensor communications pins out 
      this.Computeronboard  = ''; //Get the computer on-board list from the ajax 
      this.Navigationsense = ''; //Get the Navigation sensor data list from ajax 
      this.CellularLTEmod = ''; //Get the celllular LTE module from the list ajax request
      this.Batterylist = '';  //Get the battery list from the ajax request 
      this.BMSmod = ''; //Get the batter list from the ajax 
      
   }; 
var PowerManagement = function(){

      this.Batterylist = '';  //Get the battery list from the ajax request 
      this.BMSmod = ''; //Get the batter list from the ajax 
};
var componentsdat = new Componentsfunction();
var powersystem = new PowerManagement();
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        // Extract the function of the mesch model pickable function 
var guii = new dat.GUI({ autoPlace: false });
//var guir = new dat.GUI({ autoPlace: false });

//menu.add(text, 'message');
  

var customContainer = document.getElementById('my-gui-container');
//var customContainer1 = document.getElementById('my-guir-container');
customContainer.appendChild(guii.domElement);  
//customContainer1.appendChild(guir.domElement);
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  // Specification funtion 

  //Materials data selection function for the  
var dit = document.querySelector("#Pyrat"); // Sending the second command data function  
 //Onboard system on the product under development on the web 
var SBCSpec = document.querySelector("#SBCspec"); //Sending the data SBC specification

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   // Transducer specification design and build option 
var Transduces = document.querySelector("#TransduceSpec"); // Sending the transducer spec data 


//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  // PCB Specification of the onboard system 
var pcblayer = document.querySelector("#PCBlayer"); // Sending data for pcb specification function 
var pcbcolor = document.querySelector("#PCBcolor"); // pcb color input function
var displaycolor = document.querySelector("PCBdisColor");
var pcbmaterials = document.querySelector("#PCBmaterials"); //Sending the pcb materials selection data  

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    //MCU listed data from the selector function 
var mcuseries = document.querySelector('#MCUserieslist'); // Sending the mcu series list 
// List Series 
var neucleo144list = document.querySelector('#Neucleo144'); // Send the data of the neucleo 144 data for the mcu list 
var neucleo64list = document.querySelector('#Neucleo64'); // Send the data of the neucleo 64 data for the mcu list 
var neucleo32list = document.querySelector('#Neucleo32'); // Neucleo 32 data of the neucleo 32 data for tje mcu list  
var genericstm32F0 = document.querySelector('#GenericF0');
var genericstm32F1 = document.querySelector('#GenericF1'); // GenericF1 data for the schematic in the database request 
var genericstm32F4 = document.querySelector('#GenericF4'); // GenericF4 data for the schematics in the database request 

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // Actuators function of the robot 
var Motortype = document.querySelector("#motortype"); //Sending data for the Actuators specification function 
var Feedbacksensors = document.querySelector('#Feedbacksensors'); // Sending the sensor type into the database 
var Statussensor = document.querySelector('#Statussensors'); //Status sensor for the actuators 
var Motordriver = document.querySelector('#Motordriver'); //Motor driver selection according to the motor type selection this will be selected at the beginning
    //Battery specification  
var batteries  = document.querySelector('#battery'); // Battery data list for the analysis 

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    //Navigation system and the map function for controlling the map 
   
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // Cellular LTE module for the telepresent communication of robot and the edge computing capability function 


//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    //Transducer data for the sensor development application 
var TransducerSpec = document.querySelector("#Transducerselect");// Sensortype for select the function of the sensors  


//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   // Navigation sensor function of the robot 
var NavigationSpec = document.querySelector("#NavSpec"); //Sending the navigaction spec function 

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // Physics analysis function
    // Upload the terrain into the scene to show up the base scene terrain for adjustment  
 //Terrain adjustment data    
 var TerrainA = document.querySelector("#terrainA"); // Terrain function for the terrain adjustment   
 //Terrain friction data adjustment function inside the number input to get the value using the onChange in the input to fix the function to be able to get the data 
 var TerrainF = document.querySelector("#terrainF"); // Terrain function for the friction adjustment 
 //Rough ness data for the terrain adjustment function on the simulation scene 
 var roughnessf = document.querySelector('#terrainR'); // Terrain roughness for control parameter 
  //Gravity control function for the Threejs to adjust the environment for testing the system behevier to get the data from analysis function 
 var Gravity = document.querySelector("#gravity"); // Gravity 
 // Light intensity function 
 var Lightintense = document.querySelector("#lightintenses"); // Light intensity data for the ouput function 
 //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      // Materials light and color control materials function 
var matnameprop = document.querySelector("#Matnameprop"); // Materials name and property value attach in the file reading and collect from the dicationary function json file
var Lightmat = document.querySelector("#lightmat"); // Light materials control function       
var Densitymat = document.querySelector("#densityMat"); // Reading the density mat from the json file or database query  
var color0mat = document.querySelector("#Colormat0"); // Get the color of the materials control in the mixer 
var color1mat = document.querySelector("#Colormat1"); // Get the color of materials to control in the mixer

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     // Materials data of the model physical analysis 
 // Adjust the mass density of the model material that you selected in the specificaiton function in ordert to get the right specification for testing and running the simulation
 var densitys = document.querySelector("#density"); // Control the density of the materials function 
 // Adjust the volume for testing on the model to testing the simulation robot motion control function 
 var volume  = document.querySelector('#volume'); //Control the volume of the materials data 

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   // Code generator part for the product programming function 
   //Data for the MCU communication system 
var div = document.querySelector("#some");  // Sending the data via some variable to the quesry sector   
var CAN = document.querySelector("#CANb"); // sending the thrid command for canbus data to generate in the code 
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   //Code generator part function 
var obdetect = document.querySelector("#Obdetectsys"); // Sending the data to the object detection 
var obrecog = document.querySelector("#Obrecogsys"); // Sending the data to object recognition 
var facerecog = document.querySelector("#Facrecogsys"); //sending the data to the facerecognition function 
var posedetect = document.querySelector("#Posedetectsys"); //Sending the data to the pose detection 
var poserecog = document.querySelector("#Poserecogsys");// Sending the data to the to the pose recognition 
var kinematics = document.querySelector("#Kinematics"); // Sending the data to the kinematics function part 
var assetdemolis  = document.querySelector("#Asset"); // Setting the asset value list for the model list option
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     //Data specification output from the gui variable to manipulate the function of the mesh model on the simulation option function 

  var text = new FizzyText(); // Materials config data 
  var SerialBaudrate = new Serialbaudrate();// Serial baud rate selection function 
  var CANbusBaudrate = new CANBus(); //CAN bus baudrate selection function 
  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     // Physical Analysis function of the control parameter  to create base scene input parameter function 
  var terrainplane = new TerrainAdjust(); // Terrain function setting for the plane selection for the realistic simulation function 
  var materialcontrol = new Materialscontrol(); // Control the material light and skin function for designing the product 
 
  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // Code generator function 
  var ComputerVis = new Computevision(); // Compute vision function for the computer vision function control in the system for pre programming of the code generator 
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   // Specification function of the onboard system on the product 
  var pcbop = new Pcboption();    // PCB Specification design 
  var onboadComputing = new ComputerOnboard(); // Onboard computing for the robotics or edge computing devices  
  // Transducerfor sensors development application 
  var transducer = new Transducer(); //Transcucer select the sensors type for the search transdution schematics from database options 
  //Micro controller specification function  
  var microControl = new Microcontroller(); // Micro controller specification function 
  var actuatorDrive = new ActuatorsDive(); // Actuator drive function  
  var BatterylisAct = new Batteryactive(); // Battery list and information function 
  var assetlistdemons = new Assetlistdemo(); //Asset list function for the model demo joints analysis and calculate the model shape and positioning function   
  var meshAnim;     
  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     // Actuators kinematics control 
  var kinematicsalgo  = new  Kinematicactuators(); // Get the kinematics function for listed 
  
  //function and parameter control from the gui input  
  var f1 = gui.addFolder('Model loader');
     // List option   of model loader dialogue function
     var f8 = f1.addFolder('Convertert file'); // Automaticly convert file 
         //Load model file for the model input  
     var f14 = f1.add(params, 'loadFile').name('Load model'); // Open the file load the model into the scene 
     //var f15 = f1.add(savefile,'saveFile').name('save');  // Save the current file export to the computer of the user where using  
     //var f16 = f1.add(saveas,'saveAs').name('save as'); // Save as the computer
     var f9 = f1.addFolder('Example models');   // Marking the point where to generate the circuit into the form or shape where you point mark into the 3d scene model
          // Marking afeter load the model into the scene it will mark down the position of the pcb in the web and using the marked position as the shape of the pcb to generate the component under that pcb 
          // Get the model data and show the list of the circuit part pcb in array data structure form 
     //var fs = require('fs');
     //var files = fs.readdirSync('/var/www/idatabots/upload');
     var listdemo = ['Catbotboneslf','Catbotfullparts','Dronecontruct',''];   
     var f91 = f9.add(assetlistdemons,'assetlist',listdemo).name("Example Models&Parts"); // Calling the list model from the asset demo     
     var PartslistAssem = ['Sensors','computer','Actuators','ActuatorDriver','Battery','Camera','GPS','Acoustic']; //Get the circuit list for the motion joint control application in the robotics 
     var computerlist = ['Raspberrypi','RaspberryPiZeroW','Beagleboneblack','BeagleBoneblue','SnapDragon','Jetsonnano','JetsonXavierNX']; //Get the computer list part into the position of the mesh generate into the scene position 
     var Sensorslist = ['Microhpone-sensor','partfailuresense-sensor','Barometer-sensor','MPU6050Gyro-sensor','Gas-sensor','E-nose_sensor','Ploximetry-sensor','Touch-sensor','Laser-rangefinder-sensor']; // Get the sensors list part into the position of the mesh generate into the  scene position 
     var Actuatorslist = ['','','','','','',''];//Get the actuator list after get the actuator type get  
     var ActuatorsDriverlist = ['','','','','','','','','','','','','','']; // Get the actuator driver list to get the information to compare the function and hardware housing cover 
     var batterylist = ['','','','','','','','','']; // Get the battery list function  
     var Opticsensorlist = ['Rpicamera','','','','','','','']; // Get the optic sensor function for the camera on the robot onboard   
     var Navigationsensorlist = ['','','','','','','','','','','','']; //Get the GPS for the navigation sensor for the 
     var Acousticlist = ['Speaker','Microphone']; // Get the list of the speaker and microphone
     f91.onChange(function(value){ 
         var GetjointsData = assetdemolis.style.assetlistdemons = value;   
      // Get the model selected from the demolist for example for testing experiment on joint position detection      
         var canvas = document.getElementById("renderCanvas"); // Get the canvas element
                     var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
                     var createScene = function(){
                     var scene = new BABYLON.Scene(engine); // Create scene 
                     var gravityVector = new BABYLON.Vector3(0,-9.81, 0);
                     var physicsPlugin = new BABYLON.CannonJSPlugin();
                      // Enable gravity into the scene 
                     scene.enablePhysics(gravityVector, physicsPlugin); // Enable the physics engine 
                     
                     //scene.useRightHandedSystem = true;  //user Right Hand System
                     camera = new BABYLON.ArcRotateCamera("camera", 4.712, 1.571, 2, BABYLON.Vector3.Zero(), scene);
                     camera.attachControl(scene.getEngine().getRenderingCanvas());
                     camera.minZ = 0.1;
                     camera.maxZ = 1000;
                     camera.lowerRadiusLimit = 0.1;
                     camera.upperRadiusLimit = 5;
                     camera.wheelPrecision = 100;
                     camera.attachControl(canvas, true);
                     // Ground for positional reference
                     
                     //var ground = BABYLON.Mesh.CreateGroundFromHeightMap("ground", "/static/textures/heightMap.png", 100, 100, 100, 0, 10, scene, false);
	                  //ground.material = new BABYLON.GridMaterial("groundMaterial", scene);
                     
                     // Add the light to the scene 
                     var light1 = new BABYLON.HemisphericLight("light1",new BABYLON.Vector3(1,1,0), scene); // Adding the light into the scene 
                     var light2 = new BABYLON.PointLight("light2",new BABYLON.Vector3(0,1,1), scene); // Create the point light into the scene positioning  
                     // Create the schere to testing the mesh in the scene  
                     //var sphere = BABYLON.MeshBuilder.CreateSphere("sphere",{diameter:2},scene); // Get the sphere 
                     /*
                     BABYLON.SceneLoader.LoadAssetContainer("static/", String(GetjointsData)+".gltf", scene, function (container) {
                         var meshes = container.meshes;
                         var materials = container.materials;
                         //var skeleton = skeletons[0];
                         var mesh = meshes[0];
                         console.log(meshes[0]);
                         //Container add all scene 
                         container.addAllToScene();
                     });
                     */
                     //var strData = JSON.stringify(transformNodes);
                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(GetjointsData)+".gltf", scene, function (meshes, particleSystems, skeletons) {
                        var model = meshes[0];  // Get the model Mesh part
                        meshes[0].isPickable = true;

                      //var model1 = meshes[3]; // Get the model
                        //console.log(String(model)); //Get the model data 

                        console.log(scene.rootNodes); // Get the rootNodes successfully to get the bone and mesh list 
                        console.log(scene.rootNodes.length); // Get the root nodes length from the function from the file
                        //model.rotation.y = Math.PI*0.25; // Model mesh roation 
                        
                        var t;
                        var r; 
                        var a;
                                          
                        for(a = 0; a < scene.meshes.length; a++){
                           //Get all mesh lenght and calculate the label path position
                           console.log(scene.meshes); // Get the meshes 
                           console.log("Get the mesh lenght:"+scene.meshes[a],a);
                           console.log("Type of data:"+ String(typeof(scene.meshes[a])));  // Get the type of the meshes 
                           
                          // var advancedTexture = BABYLON.GUI.AdvancedDynamicsTexture.CreateForMesh(plane);
                           //var button1 = BABYLON.GUI.Button.CreateSimpleButton("but1",)
                        }
meshes[0].isPickable=true   // Get the feed back back from the mesh feed back to get the details and configure the parts 

// add buttons
var buttonbox = document.createElement('div');
buttonbox.id = "buttonbox";
buttonbox.style.position = "absolute";
buttonbox.style.top = "60px";
buttonbox.style.left = "85%";
buttonbox.style.border = "2pt";
buttonbox.style.padding = "2pt";
buttonbox.style.paddingRight= "2pt";
buttonbox.style.width = "10em";
buttonbox.style.display = "block";
document.body.appendChild(buttonbox);
var tTag = document.createElement('div');
tTag.id = "choose";
tTag.textContent = "Mesh name";
tTag.style.textAlign = "center";
tTag.style.border = "2pt ";
tTag.style.marginRight = "2pt";
tTag.style.marginTop = "3pt";
tTag.style.marginBottom = "2pt";
tTag.style.backgroundColor = " ";
tTag.style.width = "96%";
tTag.style.fontSize = "1.0em";
tTag.style.color = " ";
buttonbox.appendChild(tTag);

var header = document.createElement('div');
header.id = "header";
header.textContent = " ";
header.style.textAlign = "center";
header.style.border = "2pt ";
header.style.marginLeft = "1.5pt";
header.style.backgroundColor = " ";
header.style.width = "96%";
header.style.fontSize = "1.0em";
header.style.color = "white";
buttonbox.appendChild(header);
// Impact impostor
//  var impact = BABYLON.Mesh.CreatePlane("impact", 1, scene);
//impact.material = new BABYLON.StandardMaterial("impactMat", scene);
//impact.material.diffuseTexture = new BABYLON.Texture("textures/impact.png", scene);
//impact.material.diffuseTexture.hasAlpha = true;
//impact.position = new BABYLON.Vector3(0, 0, -0.1);

//When click event is raised
scene.onPointerDown = function (evt, pickResult) {
// We try to pick an object
if (pickResult.hit) {
 header.textContent = pickResult.pickedMesh.name; // Header content display
 console.log(header.textContent); 
 mockingmodel = header.textContent;
 //transformNodesName = scene.transformNodes[r].name;
 console.log(mockingmodel,"Get X ",pickResult.pickedPoint.x); //Get the X position 
 console.log(mockingmodel,"Get Y",pickResult.pickedPoint.y); //Get the Y position
 console.log(mockingmodel,"Get Z",pickResult.pickedPoint.z); //Get the Z position
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
         // Extracting the information from the mesh model pickable for function and analysis data customisation on the json file 

 header.textContent = mockingmodel
 header.textContent = "\n"+mockingmodel + "\n"+pickResult.pickedPoint.x + "\n" + pickResult.pickedPoint.y + "\n"+pickResult.pickedPoint.z;
 var mat = new BABYLON.StandardMaterial("mat", scene);
 mat.diffuseColor = BABYLON.Color3.Blue();
 scene.constantlyUpdateMeshUnderPointer = true;
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 
	// Mesh picker image and the color of the mesh display 
	scene.onPointerMove = function (evt, pickingInfo) {
		scene.meshes.forEach(function (m) {
			m.material = null;
		});
		if (pickingInfo.pickedMesh) {
			pickingInfo.pickedMesh.material = mat;  // Picking the mesh value changing on the color to marking the position for modification of the part and circuit 
		}
	}
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
     //Enable the function of the gui for controlling the parameter on each part of the module 
 



//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
}

}


                   //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                        // Get the part file name 
                  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                       //Search which part found base on the part CAD list and calculate the possiblity to generate the model where the point it live there in the position
                        for(r = 0 ; r < scene.transformNodes.length; r ++)
                       {  
                                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                 
                                       //console.log(scene.transformNodes[r].name);
                                          
                            console.log("Mesh part name data" + "\t" + scene.transformNodes[r].name);  // Get the part name of the model 
                            console.log(scene.transformNodes[r].name.split(" ")); // Get the data on the splitter to find the area that component can be place into it 
                            
                            var w; //Get the list of the data on the part search 
                            for(t = 0; t < scene.transformNodes[r].name.split(" ").length;t++){
                                              //for(w = 0; w < PartslistAssem.length ; w++){
                                 //Computer list function classify the part automaticly  
                                if(String(scene.transformNodes[r].name.split(" ")[t]) == PartslistAssem[1])
                                {
                                 
                                    console.log("Found the match part and finding" +"\t"+ String(scene.transformNodes[r].name)); // Get the part after found and add the model in the position    
                                    // Get the position of the part into the position matcth for the assembly part 
                                    //First testload multiple model input here 
                                    console.log("Get position"+ "\t"+ String(scene.transformNodes[r].position)); // Get the position of the mesh                                     
                                    model.position.x =+0.4;
                                   /*
                                    var angle2 = 0;
                                    scene.registerBeforeRender(function(){
                                    model.position.x = angle2;
                                    angle2 -=0.001;
                                    });
                                    */
                                    //meshes[4].position.x =+0.1;
                                    //meshes[5].position.x =+0.1;
                                    //meshes[19].position.x =+0.1; // Main hbody connection with the 3 servo motor at the middle and the front 2 legs 
                                    //meshes[18].position.x =- 0.1; // Front Left leg cover connector with the axis head 
                                    //meshes[17].position.x = -0.1; //Left frontleg connector 
                                    //meshes[16].position.x =- 0.1; //Left cover joint to conect to the foreum  
                                    //meshes[15].position.x =-0.1; //Front Left leg servo connection cover 
                                   // meshes[14].position.x =- 0.1; //Front Left leg axis connector 
                                    //meshes[13].position.x =- 0.1; //Left front leg main joint integration function 
                                    //meshes[12].position.x =- 0.1; //Front Left leg foreum
                                   //meshes[11].position.x =- 0.1; // Left front foot 
                                    //meshes[10].position.x =- 0.1; //Embeded camera connector 
                                    //meshes[9].position.x =- 0.1; // LED eye holder for the hyper spectral and lidar function 
                                    console.log(meshes[9].position.x +","+ meshes[9].position.y +","+ meshes[9].position.z); // Get the position of the mesh in xyz 
                                    //meshes[8].position.x =- 0.1;  // Right neck connector cover part 
                                    //meshes[7].position.x =+0.1; // Left neck connectotr cover part 
                                    //meshes[6].position.x =+ 0.1; 
                                    //meshes[20].position.x =-0.1; //Get the computer cover part 
                                   // meshes[21].position.x =+0.1; // Get the computer holder box for the SBC 
                                    // Get tbe Computer holder positioning  
                                    console.log(meshes[21].position.x +","+ meshes[21].position.y +","+ meshes[21].position.z); // Get the position of the mesh in xyz 
                                 /*
                                    BABYLON.SceneLoader.ImportMesh("","static/" ,String(computerlist[0])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                    var modelSBC = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                      modelSBC.position.x =+0.3878            // meshes[21].position.x  
                                      modelSBC.position.y =+0.10      //meshes[21].position.y
                                      modelSBC.position.z =-0.098   //meshes[21].position.z
                                      modelSBC.rotation.z = Math.PI*0.25; //Model mesh roation 
                                      modelSBC.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                      var angle = 0;
                                      scene.registerBeforeRender(function(){
                                      modelSBC.rotation.y = angle;
                                      angle +=0.01;
                                      });
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>                                   
                                    });
                                    */
                                    meshes[0].isPickable=true;
                                    meshes[0].material = new BABYLON.StandardMaterial("Model mesh", scene);

            // add buttons
            /*
            var buttonbox = document.createElement('div');
            buttonbox.id = "buttonbox";
            buttonbox.style.position = "absolute";
            buttonbox.style.top = "60px";
            buttonbox.style.left = "85%";
            buttonbox.style.border = "2pt";
            buttonbox.style.padding = "2pt";
            buttonbox.style.paddingRight= "2pt";
            buttonbox.style.width = "10em";
            buttonbox.style.display = "block";
            document.body.appendChild(buttonbox);
            */
            var tTag = document.createElement('div');
            tTag.id = "choose";
            tTag.textContent = "Mesh name";
            tTag.style.textAlign = "center";
            tTag.style.border = "2pt ";
            tTag.style.marginRight = "2pt";
            tTag.style.marginTop = "3pt";
            tTag.style.marginBottom = "2pt";
            tTag.style.backgroundColor = " ";
            tTag.style.width = "96%";
            tTag.style.fontSize = "1.0em";
            tTag.style.color = " ";
            buttonbox.appendChild(tTag);
        
            var header = document.createElement('div');
            header.id = "header";
            header.textContent = "No Picked Mesh";
            header.style.textAlign = "center";
            header.style.border = "2pt ";
            header.style.marginLeft = "1.5pt";
            header.style.backgroundColor = " ";
            header.style.width = "96%";
            header.style.fontSize = "1.0em";
            header.style.color = "white";
            buttonbox.appendChild(header);
              // Impact impostor
          //  var impact = BABYLON.Mesh.CreatePlane("impact", 1, scene);
            //impact.material = new BABYLON.StandardMaterial("impactMat", scene);
            //impact.material.diffuseTexture = new BABYLON.Texture("textures/impact.png", scene);
            //impact.material.diffuseTexture.hasAlpha = true;
            //impact.position = new BABYLON.Vector3(0, 0, -0.1);

            //When click event is raised
            
            scene.onPointerDown = function (evt, pickResult) {
                // We try to pick an object
                if (pickResult.hit) {
                    header.textContent = pickResult.pickedMesh.name;
                    console.log(header.textContent); 
                    mockingmodel = header.textContent;
                    transformNodesName = scene.transformNodes[r].name;
                    //meshes[0].position.x = pickResult.pickedPoint.x;
                 //   meshes[0].position.y = pickResult.pickedPoint.y;
                   // meshes[0].position.z = pickResult.pickedPoint.z;
                    console.log(mockingmodel,"Get X ",pickResult.pickedPoint.x); //Get the X position 
                    console.log(mockingmodel,"Get Y",pickResult.pickedPoint.y); //Get the Y position
                    console.log(mockingmodel,"Get Z",pickResult.pickedPoint.z); //Get the Z position
                    header.textContent = mockingmodel
                    header.textContent = "\n"+mockingmodel + "\n" +"\t"+transformNodesName+"\n"+pickResult.pickedPoint.x + "\n" + pickResult.pickedPoint.y + "\n"+pickResult.pickedPoint.z;
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                 //Model picked mesh function settings
                    var menu = guii.addFolder(mockingmodel);
                    var addPosition = [];
                    addPosition.push(pickResult.pickedPoint.x+","+pickResult.pickedPoint.y+","+pickResult.pickedPoint.z); 
                    console.log(addPosition);
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      // Position of the mesh model 
                    var Functiondata = ['Materials','Microcontroller','Actuator and driver','Image sensor','Computer on-board','Sensors','Acoustic amplifier','Navigation sensor','Cellular LTE module','Battery','BMS module','Non-Select']; // List data for the function setting of the parts 
                    var funco = menu.add(componentsdat,'functionapp',Functiondata).name("Select part functions");     // Get the data from the AJAX 
                    funco.setValue("Non-Select")
                    funco.onChange(function(value){
                    var funccom = funcdataset.style.componentsdat = value; 
                           console.log(funccom);  // Get the microcontroller list data output 
                   //Mesh materials position  and data 
                  if(funccom == Functiondata[0]){
                    var materials= menu.add(componentsdat,'materials',['Metal','Rubber','Plastic','Composite','Non-Select']).name("Materials-data");     // Get the data from the AJAX 
                    materials.setValue("Non-Select");
                    materials.onChange(function(value){
                    Matcom = Materialsdataset.style.Materialsdatset = value; 
                           console.log(Matcom);  // Get list data output 
                           //Getting the data of the specific materials into the manufacturing process 
                           comvis.push("Materials"+":"+Matcom); // Getting the materials data push into json 
                           // The computation here will be generate the skin for the mesh part  
                     });
                     
                      //remove the materials functioin 
                      var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                       remover.onChange(function(){
                       menu.remove(materials); // Get the 
                       menu.remove(remover);
                       
                    }); // Get the feed back data
                    
                   
                  }
                  // Microcontroler position and data 
                  if(funccom == Functiondata[1]) {
                    mcusrecord.push(mockingmodel);
                    //Get the packages model name 
                    //Setting the firmware firmata support microcontroller from the json file for auto generate list autorization for the full serial control optimization
                    var packagemodel = ['LQFP32','LQFP48','LQFP64','LQFP144','TSSOP8','TSSOP16','TSSOP20','TSSOP32','TSSOP64','UBGA64','LFBGA100','','','','','']; //Get the LQFPpackage list data for the microcontroller  
                    microlistdata = ['Neucleo-32','Neucleo-64','Neucleo-144','GenericSTM32F0Series','GenericSTM32F1Series','GenericSTM32F4Series','Non-Select']; 
                    var micro = menu.add(componentsdat,'microdata',['Neucleo-32','Neucleo-64','Neucleo-144','GenericSTM32F0Series','GenericSTM32F1Series','GenericSTM32F4Series','Non-Select']).name("STM32-MCU");     // Get the data from the AJAX 
                    micro.setValue("Non-Select");
                    micro.onChange(function(value){
                    Microcom = microdataset.style.componentsdat = value; 
                           console.log(Microcom);  // Get the microcontroller list data output 
                     });
                     inputmcu = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                           // Add the model of name from the matcom here  
                            //console.log("MCU"+":"+mcusrecord+","+"Position"+":"+addPosition+","+"Amount"+":"+inputmcu.object["Amount"]+","+String(Microcom)); // Get the data mesh input from the text input
                            // Do the function clones multiple models here 
                            if(Microcom == microlistdata[0]){
                                   console.log("Selected Neucleo-32 series");
                                   n1 = menu.add(componentsdat,'microdata',['Nucleo-F031K6','Nucleo-L031K6','Nucleo-L412KB','Nucleo-F303K8','Nucleo-G431KB']).name("Neucleo-32"); 
                                   n1.onChange(function(value){
                                   var Neucleo32data = Neucleo32.style.componentsdat = value; //Show the neucleo 
                                   console.log(String(Neucleo32data)); // Get the Neucleo32 data  
                                   alert(String(Neucleo32data));
                                   if(Neucleo32data =="Nucleo-F031K6"){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board"+ mcuData[1].Boardseries + "," +"Packages" +","+addPosition+"," + mcuData[1].mcufamily.Specifications.STM32F031K6 +"Position"+addPosition+":"+"Amount"+","+inputmcu.object["Amount"]+"mcus Spec"+"," + mcuData[1].mcufamily.descriptionsspec.STM32F031K6); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32F031K6 +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32F031K6)); //Alert the spec 
                                        //comvis.push("MCU"+":"+mcusrecord+","+"Position"+":"+addPosition+","+"Amount"+":"+inputmcu.object["Amount"]);
                                        comvis.push("Board"+","+mcuData[1].Boardseries +","+Neucleo32data+"," +"Packages" +","+addPosition+"," + mcuData[1].mcufamily.Specifications.STM32F031K6 +"Position"+addPosition+":"+"Amount"+","+inputmcu.object["Amount"]+","+"mcus Spec"+"," + mcuData[1].mcufamily.descriptionsspec.STM32F031K6);

                                        if(mcuData[1].mcufamily.Specifications.STM32F031K6[6].split(" ")[1] == 'Active'){
                  
                                                     alert(String("Part:" + mcuData[1].mcufamily.Specifications.STM32F031K6[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[1].mcufamily.Specifications.STM32F031K6; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             } 
                                                   //Get the microcontroller pins configuretion function input here 
                                             
                                           }
                                        else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }

                                   };
                                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                                  //Classifymcudata(mcuData); // Get the request from the mcu 

                            }

                            if(Neucleo32data == "Nucleo-L031K6")
                            {
                                    var mcuRequest = new XMLHttpRequest(); //
                                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                    mcuRequest.onload = function() {
                                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                    console.log("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32L031K6[0] +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32L031K6); // Microcontroller spec 
                                    alert(String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32L031K6 +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32L031K6)); //Alert the spec 
                                    comvis.push("Board"+","+mcuData[1].Boardseries + "," +"Packages" +"," + mcuData[1].mcufamily.Specifications.STM32L031K6 +":"+"mcus Spec"+"," + mcuData[1].mcufamily.descriptionsspec.STM32L031K6); 
                                    if(mcuData[1].mcufamily.Specifications.STM32L031K6[6].split(" ")[1] == 'Active'){
                                                   alert(String("Part:" + mcuData[1].mcufamily.Specifications.STM32L031K6[6].split(" ")[1])); // Get the status alert on the function 
                                                   //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                   let packages3ddata = mcuData[1].mcufamily.Specifications.STM32L031K6; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }         
                            
                                       
                                  }
                                   else{

                                       alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                  }

                            };
                            mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                            //Classifymcudata(mcuData); // Get the request from the mcu 
            
                           }
                           if(Neucleo32data == "Nucleo-L412KB")
                           { 
                                var mcuRequest = new XMLHttpRequest(); //
                                mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                mcuRequest.onload = function() {
                                var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                console.log("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32L412KB[0] +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32L412KB); // Microcontroller spec 
                                alert(String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32L412KB[0] +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32L412KB)); //Alert the spec 
                                comvis.push("Board"+","+ mcuData[1].Boardseries + "," +"Packages" +"," + mcuData[1].mcufamily.Specifications.STM32L412KB +":"+"mcus Spec"+"," + mcuData[1].mcufamily.descriptionsspec.STM32L412KB); 
                                if(mcuData[1].mcufamily.Specifications.STM32L412KB[6].split(" ")[1] == 'Active'){
                                                     alert(String("Part:" + mcuData[1].mcufamily.Specifications.STM32L412KB[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[1].mcufamily.Specifications.STM32L412KB; // Split the comma if found 
                                                     console.log(packages3ddata);
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                    }         

                        }
                        else{

                           alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                        };
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                        //Classifymcudata(mcuData); // Get the request from the mcu 
            
                    }
                    if(Neucleo32data == "Nucleo-F303K8")
                    { 
                     var mcuRequest = new XMLHttpRequest(); //
                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                        mcuRequest.onload = function() {
                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                        console.log("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32F303K8[0] +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32F303K8); // Microcontroller spec 
                        
                        alert(String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32F303K8 +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32F303K8)); //Alert the spec 
                        comvis.push([String(Neucleo32data),String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32F303K8 +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32F303K8)]); 
                        if(mcuData[1].mcufamily.Specifications.STM32F303K8[6].split(" ")[1] == 'Active'){
                          
                           alert(String("Part:" + mcuData[1].mcufamily.Specifications.STM32F303K8[6].split(" ")[1])); // Get the status alert on the function 
                           //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                           let packages3ddata = mcuData[1].mcufamily.Specifications.STM32F303K8; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                    }         

                        }
                        else{

                           alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                        };
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                        //Classifymcudata(mcuData); // Get the request from the mcu 
                 
                    }
                    if(Neucleo32data == "Nucleo-G431KB")
                    { 
                     var mcuRequest = new XMLHttpRequest(); //
                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                        mcuRequest.onload = function() {
                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                        console.log("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32G431KB[0] +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32G431KB); // Microcontroller spec 
                        
                        alert(String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32G431KB +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32G431KB)); //Alert the spec 
                        comvis.push([String(Neucleo32data),String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32G431KB +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32G431KB)]); 
                        if(mcuData[1].mcufamily.Specifications.STM32G431KB[6].split(" ")[1] == 'Active'){
                          
                           alert(String("Part:" + mcuData[1].mcufamily.Specifications.STM32G431KB[6].split(" ")[1])); // Get the status alert on the function 
                           //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                           let packages3ddata = mcuData[1].mcufamily.Specifications.STM32G431KB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                    }         
                        }
                        else{

                           alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                        };
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                        //Classifymcudata(mcuData); // Get the request from the mcu 
            
                    }
         

                });   
      
              }
             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.
                        //Neucleo64 microcontroller 
            if(Microcom == microlistdata[1]){
                         console.log("Selected Neucleo-64 series"); //Display the selected option 
                         n2 = menu.add(microControl,'Neucleo64list',['Neucleo-F030R8','Neucleo-F072RB','Neucleo-F091RC','Neucleo-F103RB','Neucleo-F103RB','Neucleo-F303R8','Neucleo-F303RE','Neucleo-F401RE','Neucleo-F411RE','Neucleo-F446RE','Neucleo-G071RB','Neucleo-G431RB','Neucleo-G474RE','Neucleo-L053R8','Neucleo-L073RZ','Neucleo-L152RE','Neucleo-L433RC-P','Neucleo-L452RE','Neucleo-L452RE-P','Neucleo-L476RG','P-Neucleo WB55RG']).name("Neucleo-64"); // Show the list data of the neucleo 64 
                         var Neucleo64s = ['Neucleo-F030R8','Neucleo-F072RB','Neucleo-F091RC','Neucleo-F103RB','Neucleo-F103RB','Neucleo-F303R8','Neucleo-F303RE','Neucleo-F401RE','Neucleo-F411RE','Neucleo-F446RE','Neucleo-G071RB','Neucleo-G431RB','Neucleo-G474RE','Neucleo-L053R8','Neucleo-L073RZ','Neucleo-L152RE','Neucleo-L433RC-P','Neucleo-L452RE','Neucleo-L452RE-P','Neucleo-L476RG','P-Neucleo WB55RG']; // Show the list data of the neucleo 64 
                         n2.onChange(function(value){
                         Neucleo64data  = neucleo64list.style.Neucleo64list = value; // Show the Neucleo 64 list data 
                         console.log(String(Neucleo64data)); // Get the Neucleo64 data  
                         if(Neucleo64data == "Neucleo-F030R8"){ 
                                      var mcuRequest = new XMLHttpRequest(); //
                                      mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                      mcuRequest.onload = function() {
                                      var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                      console.log("Board,"+ mcuData[0].Boardseries + ","+"Packages,"+mcuData[0].mcufamily.Specifications.STM32F030R8 + ":"+"mcus Spec"+"," + mcuData[0].mcufamily.descriptionsspec.STM32F030R8); // Microcontroller spec 
                                      alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F030R8 + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F030R8)); //Alert the spec  
                                      comvis.push("Board,"+ mcuData[0].Boardseries + ","+"Packages,"+mcuData[0].mcufamily.Specifications.STM32F030R8 + ":"+"mcus Spec"+"," + mcuData[0].mcufamily.descriptionsspec.STM32F030R8); 
                                      console.log(mcuData[0].mcufamily.Specifications.STM32F030R8.length); // Finding the lenght of the list package 
                                     if(mcuData[0].mcufamily.Specifications.STM32F030R8[6].split(" ")[1] == 'Active'){
                                            alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F030R8[6].split(" ")[1])); // Get the status alert on the function 
                                            //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                            let packages3ddata = mcuData[0].mcufamily.Specifications.STM32F030R8; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                    }         
                         }
                         else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                         }
        
                          };
                          mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github        
                
                        }   
                        if(Neucleo64data == "Neucleo-F072RB")       
                        {
                           var mcuRequest = new XMLHttpRequest(); //
                           mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                           mcuRequest.onload = function() {
                           var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                           console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F072RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F072RB); // Microcontroller spec 
                           alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F072RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F072RB)); //Alert the spec  
                           comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F072RB +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F072RB)]); 
                          if(mcuData[0].mcufamily.Specifications.STM32F072RB[6].split(" ")[1] == 'Active'){
                             alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F072RB[6].split(" ")[1])); // Get the status alert on the function 
                             //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                             let packages3ddata = mcuData[0].mcufamily.Specifications.STM32F072RB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                    }           
                       
                           }
                        else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }
        
                       };
                     mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github          
                     }
                     if(Neucleo64data == "Neucleo-F091RC")       
                     {
                        var mcuRequest = new XMLHttpRequest(); //
                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                        mcuRequest.onload = function() {
                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                        console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F091RC + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F091RC); // Microcontroller spec 
                        alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F091RC + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F091RC)); //Alert the spec  
                        comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F091RC +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F091RC)]); 
                       if(mcuData[0].mcufamily.Specifications.STM32F091RC[6].split(" ")[1] == 'Active'){
                          
                             alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F091RC[6].split(" ")[1])); // Get the status alert on the function 
                             //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                             let packages3ddata = mcuData[0].mcufamily.Specifications.STM32F091RC; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                    }                       
                
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github             
           }
           if(Neucleo64data == "Neucleo-F103RB")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F103RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F103RB); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F103RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F103RB)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F103RB +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F103RB)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F103RB[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F103RB[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32F103RB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github     
           }
           if(Neucleo64data == "Neucleo-F303R8")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F303R8 + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F303R8); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F303R8 + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F303R8)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F303R8 +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F303R8)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F303R8[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F303R8[6].split(" ")[1])); // Get the status alert on the function   
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32F303R8; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           
               }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github  
           }
           if(Neucleo64data == "Neucleo-F303RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F303RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F303RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F303RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F303RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F303RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F303RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F303R8[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F303RE[6].split(" ")[1])); // Get the status alert on the function  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32F303RE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           

                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
           }
           if(Neucleo64data == "Neucleo-F401RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F401RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F401RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F401RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F401RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F401RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F401RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F401RE[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F401RE[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32F401RE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           

                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github         
           }
           if(Neucleo64data == "Neucleo-F411RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F411RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F411RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F411RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F411RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F411RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F411RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F411RE[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F411RE[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32F411RE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           

                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github  
           }
           if(Neucleo64data == "Neucleo-F446RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F446RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F446RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F446RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F446RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F446RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F446RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F446RE[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F446RE[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32F446RE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                          }           
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github     
           }
           if(Neucleo64data == "Neucleo-G071RB")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G071RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G071RB); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G071RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G071RB)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G071RB +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G071RB)]); 
               if(mcuData[0].mcufamily.Specifications.STM32G071RB[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32G071RB[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32G071RB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
           }
           if(Neucleo64data == "Neucleo-G431RB")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G431RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G431RB); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G431RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G431RB)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F446RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G431RB)]); 
               if(mcuData[0].mcufamily.Specifications.STM32G431RE[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32G431RB[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32G431RB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           

                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github           
           }
           if(Neucleo64data == "Neucleo-G474RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G474RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G474RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G474RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G474RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G474RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G474RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32G474RE[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32G474RE[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32G474RE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github               
           }
           if(Neucleo64data == "Neucleo-L053R8")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L053R8 + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L053R8); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L053R8 + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L053R8)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L053R8 +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L053R8)]); 
               if(mcuData[0].mcufamily.Specifications.STM32L053R8[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L053R8[6].split(" ")[1])); // Get the status alert on the function  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32L053R8; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }                    
               }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github             
           }
           if(Neucleo64data == "Neucleo-L073RZ")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L073RZ + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L073RZ); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L073RZ + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L073RZ)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L073RZ +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L073RZ)]); 
               if(mcuData[0].mcufamily.Specifications.STM32G073RZ[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L073RZ[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32L073RZ; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           

                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github    
           }
           if(Neucleo64data == "Neucleo-L152RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L152RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L152RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L152RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L152RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L073RZ +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L152RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32G073RZ[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L073RZ[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32L073RZ; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github       
           }
           if(Neucleo64data == "Neucleo-L433RC-P")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L433RCP + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L433RCP); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L433RCP + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L433RCP)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L433RCP +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L433RCP)]); 
               if(mcuData[0].mcufamily.Specifications.STM32L433RCP[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L433RCP[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32L433RCP; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           
                
               }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github         
           }
           if(Neucleo64data == "Neucleo-L452RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32L452RE[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L452RE[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32L452RE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github         
           }
           if(Neucleo64data == "Neucleo-L452RE-P")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452REP + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452REP); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452REP + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452REP)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452REP +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452REP)]); 
               if(mcuData[0].mcufamily.Specifications.STM32L452REP[6].split(" ")[1] == 'Active'){
                          
                           alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L452REP[6].split(" ")[1])); // Get the status alert on the function 
                           //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                           let packages3ddata = mcuData[0].mcufamily.Specifications.STM32L452REP; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           
                
                        }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github       
           }
           if(Neucleo64data == "Neucleo-L476RG")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L476RG + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L476RG); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L476RG + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L476RG)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L476RG +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L476RG)]); 
               if(mcuData[0].mcufamily.Specifications.STM32L476RG[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L476RG[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.STM32L476RG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               }
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github    
           }
           if(Neucleo64data == "P-Neucleo WB55RG")          
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.PNeucleoWB55RG + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.PNeucleoWB55RG); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.PNeucleoWB55RG + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.PNeucleoWB55RG)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.PNeucleoWB55RG +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.PNeucleoWB55RG)]); 
               if(mcuData[0].mcufamily.Specifications.PNeucleoWB55RG[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[0].mcufamily.Specifications.PNeucleoWB55RG[6].split(" ")[1])); // Get the status alert on the function 
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                          let packages3ddata = mcuData[0].mcufamily.Specifications.PNeucleoWB55RG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                    }           


                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               }
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github          
           }   



                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                           //end of the Neucleo 64 
                  });
               
            }
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                   // Neucleo-144 
            if(Microcom == microlistdata[2]){
               console.log("Selected Neucleo-144 series"); // Display the selected option 
               n3 = menu.add(componentsdat,'microdata',['Neucleo F207ZG','Neucleo F429ZI','Neucleo F756ZG','Neucleo F767ZI','Neucleo F767ZI','Neucleo H743ZI','Neucleo H743ZI2','Neucleo L496ZG','Neucleo L496ZG-P','Neucleo L4R5ZI','Neucleo L4R5ZI-P']).name("Neucleo-144"); //Get the neucleo 144 series for list and schematic builder 
               var  Neucleo144s = ["Neucleo F207ZG","Neucleo F429ZI","Neucleo F756ZG","Neucleo F767ZI","Neucleo F767ZI","Neucleo H743ZI","Neucleo H743ZI2","Neucleo L496ZG","Neucleo L496ZG-P","Neucleo L4R5ZI","Neucleo L4R5ZI-P"]; 
               n3.onChange(function(value){
                 //Extract the list of the neucleo -144 board
                 var Neucleo144data = neucleo144list.style.Neucleo144list = value; // Get the value of the Neucleo 144 for the pins display and schematic for modify the user circuit board for the robot onboard 
                 console.log(String(Neucleo144data)); // Get the Neucleo144 data
             if(Neucleo144data == "Neucleo F207ZG"){

                     var mcuRequest = new XMLHttpRequest(); //
                     mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                     mcuRequest.onload = function() {
                     var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                     console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F207ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F207ZG); // Microcontroller spec 
                     alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F207ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F207ZG)); //Alert the spec  
                     comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F207ZG +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F207ZG)]); 
                     if(mcuData[2].mcufamily.Specifications.STM32F207ZG[6].split(" ")[1] == 'Active'){
                          
                                 alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32F207ZG[6].split(" ")[1])); // Get the status alert on the function 
                                 //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                 let packages3ddata = mcuData[2].mcufamily.Specifications.STM32F207ZG; // Split the comma if found
                                 console.log(packages3ddata);  
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                    for(qr = 0; qr <= packages3ddata.length; qr++){
                                                     console.log(String(packages3ddata[0].split(',')[qr-1]));
                                                     
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                   }         
                     }
                     else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                     }
        
               }
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github 
             } 
             if(Neucleo144data == String(Neucleo144s[1])){

                                 var mcuRequest = new XMLHttpRequest(); //
                                 mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                 mcuRequest.onload = function() {
                                 var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                 console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F429ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F429ZI); // Microcontroller spec 
                                 alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F429ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F429ZI)); //Alert the spec  
                                 comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F429ZI +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F429ZI)]); 
                                 if(mcuData[2].mcufamily.Specifications.STM32F429ZI[6].split(" ")[1] == 'Active'){
           
                                             alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32F429ZI[6].split(" ")[1])); // Get the status alert on the function 
                                             //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                             let packages3ddata = mcuData[2].mcufamily.Specifications.STM32F429ZI; // Split the comma if found
                                                    console.log(packages3ddata);  
                                                      //extracting list packages data in the list 
                                                    var qr = 0; 
                                                    for(qr = 0; qr <= packages3ddata.length; qr++){
                                                     console.log(String(packages3ddata[0].split(',')[qr-1]));
                                                     
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                   }         
                                 
                                  }
                                 else{
                                      alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                 }

                         }
                          mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                       }     
                       if(Neucleo144data == String(Neucleo144s[2])){
                               var mcuRequest = new XMLHttpRequest(); //
                               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                               mcuRequest.onload = function() {
                               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                               console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F756ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F756ZG); // Microcontroller spec  
                               alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F756ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F756ZG)); //Alert the spec  
                               comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F756ZG +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F756ZG)]); 
                               if(mcuData[2].mcufamily.Specifications.STM32F756ZG[6].split(" ")[1] == 'Active'){
                                       alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32F756ZG[6].split(" ")[1])); // Get the status alert on the function 
                                        //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                        let packages3ddata = mcuData[2].mcufamily.Specifications.STM32F756ZG; // Split the comma if found
                                                    console.log(packages3ddata);  
                                                      //extracting list packages data in the list 
                                                    var qr = 0; 
                                                    for(qr = 0; qr <= packages3ddata.length; qr++){
                                                     console.log(String(packages3ddata[0].split(',')[qr-1]));
                                                     
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                   }         
                               
                               }
                               else{
                                    alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                               }

                        }
                         mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github 
                        }
                        if(Neucleo144data == String(Neucleo144s[3])){

                            var mcuRequest = new XMLHttpRequest(); //
                            mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                            mcuRequest.onload = function() {
                            var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                            console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI); // Microcontroller spec 
                            alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI)); //Alert the spec  
                            comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI)]); 
                            if(mcuData[2].mcufamily.Specifications.STM32F767ZI[6].split(" ")[1] == 'Active'){
                                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32F767ZI[6].split(" ")[1])); // Get the status alert on the function 
                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                     let packages3ddata = mcuData[2].mcufamily.Specifications.STM32F767ZI; // Split the comma if found
                                                    console.log(packages3ddata);  
                                                      //extracting list packages data in the list 
                                                    var qr = 0; 
                                                    for(qr = 0; qr <= packages3ddata.length; qr++){
                                                     console.log(String(packages3ddata[0].split(',')[qr-1]));
                                                     
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                   }         
                          }
                        else{
                             alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                        }
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github    
                       }
                       if(Neucleo144data == String(Neucleo144s[4]))       
                       {

                        var mcuRequest = new XMLHttpRequest(); //
                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                        mcuRequest.onload = function() {
                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                        console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI); // Microcontroller spec 
                        alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI)); //Alert the spec  
                        comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI)]); 
                        if(mcuData[2].mcufamily.Specifications.STM32F767ZI[6].split(" ")[1] == 'Active'){
                              alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32F767ZI[6].split(" ")[1])); // Get the status alert on the function 
                              //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                              let packages3ddata = mcuData[2].mcufamily.Specifications.STM32F767ZI; // Split the comma if found
                                                    console.log(packages3ddata);  
                                                      //extracting list packages data in the list 
                                                    var qr = 0; 
                                                    for(qr = 0; qr <= packages3ddata.length; qr++){
                                                     console.log(String(packages3ddata[0].split(',')[qr-1]));
                                                     
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                   }         
                        
                        }
                        else{
                            alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                       }

                       }
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                       }
                      if(Neucleo144data == String(Neucleo144s[5]))       
                     {
                       var mcuRequest = new XMLHttpRequest(); //
                       mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                       mcuRequest.onload = function() {
                       var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                       console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI); // Microcontroller spec 
                       alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI)); //Alert the spec  
                       comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI)]); 
                       if(mcuData[2].mcufamily.Specifications.STM32H743ZI[6].split(" ")[1] == 'Active'){
                            alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32H743ZI[6].split(" ")[1])); // Get the status alert on the function 
                            //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                            let packages3ddata = mcuData[2].mcufamily.Specifications.STM32H743ZI; // Split the comma if found
                                                    console.log(packages3ddata);  
                                                      //extracting list packages data in the list 
                                                    var qr = 0; 
                                                    for(qr = 0; qr <= packages3ddata.length; qr++){
                                                     console.log(String(packages3ddata[0].split(',')[qr-1]));
                                                     
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                   }              
                        
                        
                      }
                       else{
                            alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                       }

                       }
                       mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github     
                       }
                       if(Neucleo144data == String(Neucleo144s[6]))       
                       {
                          var mcuRequest = new XMLHttpRequest(); //
                          mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                          mcuRequest.onload = function() {
                          var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                          console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI2 + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI2); // Microcontroller spec 
                          alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI2 + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI2)); //Alert the spec  
                          comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI2 +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI2)]); 
                          if(mcuData[2].mcufamily.Specifications.STM32H743ZI2[6].split(" ")[1] == 'Active'){
                               alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32H743ZI2[6].split(" ")[1])); // Get the status alert on the function 
                              //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                              let packages3ddata = mcuData[2].mcufamily.Specifications.STM32H743ZI2; // Split the comma if found
                                                    console.log(packages3ddata);  
                                                      //extracting list packages data in the list 
                                                    var qr = 0; 
                                                    for(qr = 0; qr <= packages3ddata.length; qr++){
                                                     console.log(String(packages3ddata[0].split(',')[qr-1]));
                                                     
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                   }         
                          
                          
                          
                          }
                          else{
                             alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                          }
                         }
                         mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                         }
                        if(Neucleo144data == String(Neucleo144s[7]))       
                        {
                           var mcuRequest = new XMLHttpRequest(); //
                           mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                           mcuRequest.onload = function() {
                           var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                           console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZG); // Microcontroller spec 
                           alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZG)); //Alert the spec  
                           comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZG +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZG)]); 
                           if(mcuData[2].mcufamily.Specifications.STM32L496ZG[6].split(" ")[1] == 'Active'){
                                alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32L496ZG[6].split(" ")[1])); // Get the status alert on the function 
                                //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                let packages3ddata = mcuData[2].mcufamily.Specifications.STM32L496ZG; // Split the comma if found
                                                    console.log(packages3ddata);  
                                                      //extracting list packages data in the list 
                                                    var qr = 0; 
                                                    for(qr = 0; qr <= packages3ddata.length; qr++){
                                                     console.log(String(packages3ddata[0].split(',')[qr-1]));
                                                     
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                   }               
                           
                        }
                        else{
                             alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                        }
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
                     }
                     if(Neucleo144data == String(Neucleo144s[8]))       
                     {
                       var mcuRequest = new XMLHttpRequest(); //
                       mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                       mcuRequest.onload = function() {
                       var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                       console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZGP + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZGP); // Microcontroller spec 
                       alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZGP + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZGP)); //Alert the spec  
                       comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZGP +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZGP)]); 
                       if(mcuData[2].mcufamily.Specifications.STM32L496ZGP[6].split(" ")[1] == 'Active'){
                              alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32L496ZGP[6].split(" ")[1])); // Get the status alert on the function 
                              //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                              let packages3ddata = mcuData[2].mcufamily.Specifications.STM32L496ZGP; // Split the comma if found
                                                    console.log(packages3ddata);  
                                                      //extracting list packages data in the list 
                                                    var qr = 0; 
                                                    for(qr = 0; qr <= packages3ddata.length; qr++){
                                                     console.log(String(packages3ddata[0].split(',')[qr-1]));
                                                     
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                   }                   
                       
                       
                       
                       }
                       else{
                           alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                       }
 
                      };
                      mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github    
                      }
                      if(Neucleo144data == String(Neucleo144s[9]))       
                     {
                        var mcuRequest = new XMLHttpRequest(); //
                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                        mcuRequest.onload = function() {
                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                        console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZI); // Microcontroller spec 
                        alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZI)); //Alert the spec  
                        comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZI +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZI)]); 
                        if(mcuData[2].mcufamily.Specifications.STM32L4R5ZI[6].split(" ")[1] == 'Active'){
          
                         alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32L4R5ZI[6].split(" ")[1])); // Get the status alert on the function 
                         //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                         let packages3ddata = mcuData[2].mcufamily.Specifications.STM32L4R5ZI; // Split the comma if found
                                                    console.log(packages3ddata);  
                                                      //extracting list packages data in the list 
                                                    var qr = 0; 
                                                    for(qr = 0; qr <= packages3ddata.length; qr++){
                                                     console.log(String(packages3ddata[0].split(',')[qr-1]));
                                                     
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                   }         
                        
                        }
                        else{
                            alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                       };
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github       
                       }
                       if(Neucleo144data == String(Neucleo144s[10]))       
                       {
                        var mcuRequest = new XMLHttpRequest(); //
                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                        mcuRequest.onload = function() {
                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                        console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZIP + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZIP); // Microcontroller spec 
                        alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZIP + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZIP)); //Alert the spec  
                        comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZIP +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZIP)]); 
                        if(mcuData[2].mcufamily.Specifications.STM32L4R5ZIP[6].split(" ")[1] == 'Active'){
                                alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32L4R5ZIP[6].split(" ")[1])); // Get the status alert on the function 
                                //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                let packages3ddata = mcuData[2].mcufamily.Specifications.STM32L4R5ZIP; // Split the comma if found
                                                    console.log(packages3ddata);  
                                                      //extracting list packages data in the list 
                                                    var qr = 0; 
                                                    for(qr = 0; qr <= packages3ddata.length; qr++){
                                                     console.log(String(packages3ddata[0].split(',')[qr-1]));
                                                     
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             
                                   }              
                        
                        
                        }
                        else{
                           alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                     };
                     mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github         
                  }

               //end of Neucleo-144
              });  
            }
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                    // GenericSTM32F0 
            if(Microcom == microlistdata[3]){
                   console.log("Selected GenericSTM32F0 series");
                   n4 = menu.add(componentsdat,'microdata',['STM32F030F4']).name("GenericF0-Series"); 
                   n4.onChange(function(value){
                   var GenericF0data = GenericF0.style.componentsdat = value; //Show the neucleo 
                   console.log(String(GenericF0data)); // Get the Neucleo32 data  
                   alert(String(GenericF0data));
                   if(GenericF0data =="STM32F030F4"){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[3].Boardseries + "," +"Packages:" +"\t" + mcuData[3].mcufamily.Specifications.STM32F030F4[0] +","+"mcus Spec:"+"\t" + mcuData[3].mcufamily.descriptionsspec.STM32F030F4); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[3].Boardseries + "," +"Packages:" +"\t" + mcuData[3].mcufamily.Specifications.STM32F030F4 +","+"mcus Spec:"+"\t" + mcuData[3].mcufamily.descriptionsspec.STM32F030F4)); //Alert the spec 
                                        comvis.push([String(GenericF0data),String("Board:"+ mcuData[3].Boardseries + "," +"Packages:" +"\t" + mcuData[3].mcufamily.Specifications.STM32F030F4 +","+"mcus Spec:"+"\t" + mcuData[3].mcufamily.descriptionsspec.STM32F030F4)]); 
                                        if(mcuData[3].mcufamily.Specifications.STM32F030F4[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[3].mcufamily.Specifications.STM32F030F4[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[3].mcufamily.Specifications.STM32F030F4; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
               //end of GenericSTM32F0 
               });
            }
              //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                   // GenericSTM32F1 
            if(Microcom == microlistdata[4]){
               console.log("Selected GenericSTM32F1 series");
                   var GenericF1list = ["STM32F103C6","STM32F103C8","STM32F103CB","STM32F103C4","STM32F103R4","STM32F103R6","STM32F103R8","STM32F103RC","STM32F103RD","STM32F103RE","STM32F103RF","STM32F103RG","STM32F103T4","STM32F103T6","STM32F103TB","STM32F103V8","STM32F103VB", "STM32F103VC","STM32F103VD","STM32F103VE","STM32F103VF","STM32F103VG","STM32F103ZC","STM32F103ZD","STM32F103ZE","STM32F103ZF","STM32F103ZG","STM32F103ZET6","HYTinySTM32F103TB","MapleSTM32F103CB"];
                   n5 = menu.add(componentsdat,'microdata',["STM32F103C6","STM32F103C8","STM32F103CB","STM32F103C4","STM32F103R4","STM32F103R6","STM32F103R8","STM32F103RC","STM32F103RD","STM32F103RE","STM32F103RF","STM32F103RG","STM32F103T4","STM32F103T6","STM32F103TB","STM32F103V8","STM32F103VB", "STM32F103VC","STM32F103VD","STM32F103VE","STM32F103VF","STM32F103VG","STM32F103ZC","STM32F103ZD","STM32F103ZE","STM32F103ZF","STM32F103ZG","STM32F103ZET6","HYTinySTM32F103TB","MapleSTM32F103CB"]).name("GenericF1-Series"); 
                   n5.onChange(function(value){
                   var GenericF1data = GenericF1.style.componentsdat = value; //Show the neucleo 
                   console.log(String(GenericF1data)); // Get the Neucleo32 data  
                   alert(String(GenericF1data));
                   if(GenericF1data == GenericF1list[0]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C6[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C6); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C6 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C6)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C6 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C6)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103C6[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103C6[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103C6; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }  
                                           
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.
                                                                     //Get the microcontroller information and pins information 
                                             var mcuInfo = new XMLHttpRequest(); //
                                             mcuInfo.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/Microdatajson.github.io/main/'+String(GenericF1list[0])+'Tx.json'); // Get the Json data of the micro controller specification data structure
                                             mcuInfo.onload = function() {
                                             var mcuDatainfo = JSON.parse(mcuInfo.responseText); // Get the mcu data from the json file request
                                             console.log("Data mcu list");
                                             console.log(mcuDatainfo.Mcu.Pin);  //Get the microcontroller data pin
                                             console.log(mcuDatainfo.Mcu.Core);
                                             console.log(mcuDatainfo.Mcu.Current);
                                             console.log(mcuDatainfo.Mcu.IP);
                                             listmcusPins = mcuDatainfo.Mcu.Pin;
                                             listmcuscommunication = mcuDatainfo.Mcu.IP;
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      // Json parser for classify the power pins and communicaitons pint for connecting with the sensor and other components 
                                             var obj = JSON.parse('{ "Power":["VSS","VDD"], "Boot":["BOOT0","BOOT1"], "I2C":["SDA","SCL"],"SPI":["NSS","SCK","MISO","MOSI"],"UART":["RX","TX"],"USB":["DP","DM"]}');
                                             console.log(obj.Power[0]);
                                             var Pinsfunc = [];
                                             for(var k in obj){ 
                                               console.log(obj[k]); // Get the function pins for select the function pins selection and connection with the sensor and motor driver board 
                                              }
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                    //Sensor request for the communication and pins conneciton 
                                             var sensorInfo = new XMLHttpRequest(); //
                                             var sensorDatainfo;
                                             sensorInfo.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/Sensor_specification/main/sensorspec.json'); // Get the Json data of the micro controller specification data structure
                                             sensorInfo.onload = function() {
                                             var sensorDatainfo = JSON.parse(sensorInfo.responseText); // Get the mcu data from the json file request 
                                             
                                             console.log(sensorDatainfo.sensor.PhysicsSensor.IMU); // Get the sensor data list communication and 
                                             console.log(sensorDatainfo.sensor.BioSensor.Heartrate); // Get the heartrate sensor for the bio sensor 
                                             console.log(sensorDatainfo.sensor.ChemicalSensor.CO2sensor); //Get the chemical sensor data 
                                             var sensorpart = [];
                                             for(var s in sensorDatainfo.sensor){
                                                 console.log(sensorDatainfo.sensor[s]); // Get the list type of the sensor parts from the key 
                                             } 
                                          }
                                            sensorInfo.send();
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                             var i = 0; 
                                             for(i = 0 ; i < listmcusPins.length;i++){
                                                 // Pins auto circuit connection function read the pins type 
                                                 console.log(i,listmcusPins[i]._Name); // Get the pins name 
                                                 console.log(i,listmcusPins[i]._Type); // Get the pins type of the microcontroller compare type of the servo 
                                                 console.log(i,listmcusPins[i]._Instancename); //
                                                 try{
                                                 console.log(i,listmcusPins[i].Signal[0]); // Get the signal pins                                           
                                                 var q = 0; 
                                                 for(q = 0; q < listmcusPins[i].Signal.length;q++){
                                                    
                                                    console.log(listmcusPins[i].Signal[q]._Name);  // Getting the pins function of the microcontroller 
                                                    // Checking the pins 

                                                 }
                                                }
                                                 catch{
                                                  console.log("Undefines"); // For the undetecte signal  with no connection 
                                                 }   
                                             }
                                             console.log("Pins IO and communication function");
                                             r = 0; 
                                             for(r = 0; r< listmcuscommunication.length;r++)
                                             {
                                                console.log(listmcuscommunication[r]);
                                                console.log(listmcuscommunication[r]._ConfigFile); 
                                                console.log(listmcuscommunication[r]._Name);
                                              }

                                             }
                                             mcuInfo.send()   //Sending the request for the microcontroller
                                                     
                                 }
                                  else
                                 {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                               }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                 if(GenericF1data == GenericF1list[1]){
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C8[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C8); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C8 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C8)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C8 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C8)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103C8[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103C8[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103C8; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    
                                            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                     //Get the microcontroller information and pins information 
                                             var mcuInfo = new XMLHttpRequest(); //
                                             mcuInfo.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/Microdatajson.github.io/main/'+String(GenericF1list[1])+'Tx.json'); // Get the Json data of the micro controller specification data structure
                                             mcuInfo.onload = function() {
                                             var mcuDatainfo = JSON.parse(mcuInfo.responseText); // Get the mcu data from the json file request
                                             console.log("Data mcu list");
                                             console.log(mcuDatainfo.Mcu.Pin);  //Get the microcontroller data pin
                                             console.log(mcuDatainfo.Mcu.Core);
                                             console.log(mcuDatainfo.Mcu.Current);
                                             console.log(mcuDatainfo.Mcu.IP);
                                             listmcusPins = mcuDatainfo.Mcu.Pin;
                                             listmcuscommunication = mcuDatainfo.Mcu.IP;
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      // Json parser for classify the power pins and communicaitons pint for connecting with the sensor and other components 
                                             var obj = JSON.parse('{ "Power":["VSS","VDD"], "Boot":["BOOT0","BOOT1"], "I2C":["SDA","SCL"],"SPI":["NSS","SCK","MISO","MOSI"],"UART":["RX","TX"],"USB":["DP","DM"]}');
                                             console.log(obj.Power[0]);
                                             var Pinsfunc = [];
                                             for(var k in obj){ 
                                               console.log(Pinsfunc.push(k)); // Get the function pins for select the function pins selection and connection with the sensor and motor driver board 
                                              }
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                             var i = 0; 
                                             for(i = 0 ; i < listmcusPins.length;i++){
                                                 // Pins auto circuit connection function read the pins type 
                                                 console.log(i,listmcusPins[i]._Name); // Get the pins name 
                                                 console.log(i,listmcusPins[i]._Type); // Get the pins type of the microcontroller compare type of the servo 
                                                 console.log(i,listmcusPins[i]._Instancename); //
                                                 try{
                                                 console.log(i,listmcusPins[i].Signal[0]); // Get the signal pins                                           
                                                 var q = 0; 
                                                 for(q = 0; q < listmcusPins[i].Signal.length;q++){
                                                    
                                                    console.log(listmcusPins[i].Signal[q]._Name);  // Getting the pins function of the microcontroller 
                                                     
                                                 }
                                                }
                                                 catch{
                                                  console.log("Undefines"); // For the undetecte signal  with no connection 
                                                 }   
                                             }
                                             console.log("Pins IO and communication function");
                                             r = 0; 
                                             for(r = 0; r< listmcuscommunication.length;r++)
                                             {
                                                console.log(listmcuscommunication[r]);
                                                console.log(listmcuscommunication[r]._ConfigFile); 
                                                console.log(listmcuscommunication[r]._Name);
                                              }

                                             }
                                             mcuInfo.send()   //Sending the request for the microcontroller 
                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      



                 }
                 if(GenericF1data == GenericF1list[2]){
          
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103CB[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103CB); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103CB +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103CB)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103CB +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103CB)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103CB[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103CB[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103CB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             } 
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                     //Get the microcontroller information and pins information 
                                             var mcuInfo = new XMLHttpRequest(); //
                                             mcuInfo.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/Microdatajson.github.io/main/'+String(GenericF1list[2])+'Tx.json'); // Get the Json data of the micro controller specification data structure
                                             mcuInfo.onload = function() {
                                             var mcuDatainfo = JSON.parse(mcuInfo.responseText); // Get the mcu data from the json file request
                                             console.log("Data mcu list");
                                             console.log(mcuDatainfo.Mcu.Pin);  //Get the microcontroller data pin
                                             console.log(mcuDatainfo.Mcu.Core);
                                             console.log(mcuDatainfo.Mcu.Current);
                                             console.log(mcuDatainfo.Mcu.IP);
                                             listmcusPins = mcuDatainfo.Mcu.Pin;
                                             listmcuscommunication = mcuDatainfo.Mcu.IP;
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      // Json parser for classify the power pins and communicaitons pint for connecting with the sensor and other components 
                                             var obj = JSON.parse('{ "Power":["VSS","VDD"], "Boot":["BOOT0","BOOT1"], "I2C":["SDA","SCL"],"SPI":["NSS","SCK","MISO","MOSI"],"UART":["RX","TX"],"USB":["DP","DM"]}');
                                             console.log(obj.Power[0]);
                                             var Pinsfunc = [];
                                             for(var k in obj){ 
                                               console.log(Pinsfunc.push(k)); // Get the function pins for select the function pins selection and connection with the sensor and motor driver board 
                                              }
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                             var i = 0; 
                                             for(i = 0 ; i < listmcusPins.length;i++){
                                                 // Pins auto circuit connection function read the pins type 
                                                 console.log(i,listmcusPins[i]._Name); // Get the pins name 
                                                 console.log(i,listmcusPins[i]._Type); // Get the pins type of the microcontroller compare type of the servo 
                                                 console.log(i,listmcusPins[i]._Instancename); //
                                                 try{
                                                 console.log(i,listmcusPins[i].Signal[0]); // Get the signal pins                                           
                                                 var q = 0; 
                                                 for(q = 0; q < listmcusPins[i].Signal.length;q++){
                                                    
                                                    console.log(listmcusPins[i].Signal[q]._Name);  // Getting the pins function of the microcontroller 
                                                     
                                                 }
                                                }
                                                 catch{
                                                  console.log("Undefines"); // For the undetecte signal  with no connection 
                                                 }   
                                             }
                                             console.log("Pins IO and communication function");
                                             r = 0; 
                                             for(r = 0; r< listmcuscommunication.length;r++)
                                             {
                                                console.log(listmcuscommunication[r]);
                                                console.log(listmcuscommunication[r]._ConfigFile); 
                                                console.log(listmcuscommunication[r]._Name);
                                              }

                                             }
                                             mcuInfo.send()   //Sending the request for the microcontroller               

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      


                 }
                 if(GenericF1data == GenericF1list[3]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C4[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C4); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C4 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C4)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C4 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C4)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103C4[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103C4[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103C4; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>    
                                                  //Get the microcontroller information and pins information 
                                             var mcuInfo = new XMLHttpRequest(); //
                                             mcuInfo.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/Microdatajson.github.io/main/'+String(GenericF1list[3])+'Tx.json'); // Get the Json data of the micro controller specification data structure
                                             mcuInfo.onload = function() {
                                             var mcuDatainfo = JSON.parse(mcuInfo.responseText); // Get the mcu data from the json file request
                                             console.log("Data mcu list");
                                             console.log(mcuDatainfo.Mcu.Pin);  //Get the microcontroller data pin
                                             console.log(mcuDatainfo.Mcu.Core);
                                             console.log(mcuDatainfo.Mcu.Current);
                                             console.log(mcuDatainfo.Mcu.IP);
                                             listmcusPins = mcuDatainfo.Mcu.Pin;
                                             listmcuscommunication = mcuDatainfo.Mcu.IP;
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      // Json parser for classify the power pins and communicaitons pint for connecting with the sensor and other components 
                                             var obj = JSON.parse('{ "Power":["VSS","VDD"], "Boot":["BOOT0","BOOT1"], "I2C":["SDA","SCL"],"SPI":["NSS","SCK","MISO","MOSI"],"UART":["RX","TX"],"USB":["DP","DM"]}');
                                             console.log(obj.Power[0]);
                                             var Pinsfunc = [];
                                             for(var k in obj){ 
                                               console.log(Pinsfunc.push(k)); // Get the function pins for select the function pins selection and connection with the sensor and motor driver board 
                                              }
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                             var i = 0; 
                                             for(i = 0 ; i < listmcusPins.length;i++){
                                                 // Pins auto circuit connection function read the pins type 
                                                 console.log(i,listmcusPins[i]._Name); // Get the pins name 
                                                 console.log(i,listmcusPins[i]._Type); // Get the pins type of the microcontroller compare type of the servo 
                                                 console.log(i,listmcusPins[i]._Instancename); //
                                                 try{
                                                 console.log(i,listmcusPins[i].Signal[0]); // Get the signal pins                                           
                                                 var q = 0; 
                                                 for(q = 0; q < listmcusPins[i].Signal.length;q++){
                                                    
                                                    console.log(listmcusPins[i].Signal[q]._Name);  // Getting the pins function of the microcontroller 
                                                     
                                                 }
                                                }
                                                 catch{
                                                  console.log("Undefines"); // For the undetecte signal  with no connection 
                                                 }   
                                             }
                                             console.log("Pins IO and communication function");
                                             r = 0; 
                                             for(r = 0; r< listmcuscommunication.length;r++)
                                             {
                                                console.log(listmcuscommunication[r]);
                                                console.log(listmcuscommunication[r]._ConfigFile); 
                                                console.log(listmcuscommunication[r]._Name);
                                              }

                                             }
                                             mcuInfo.send()   //Sending the request for the microcontroller 
                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      





                        }
                 if(GenericF1data == GenericF1list[4]){
                 
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C4[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C4); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C4 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C4)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103C4 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C4)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103C4[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103C4[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103C4; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             } 
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                  //Get the microcontroller information and pins information 
                                             var mcuInfo = new XMLHttpRequest(); //
                                             mcuInfo.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/Microdatajson.github.io/main/'+String(GenericF1list[4])+'Tx.json'); // Get the Json data of the micro controller specification data structure
                                             mcuInfo.onload = function() {
                                             var mcuDatainfo = JSON.parse(mcuInfo.responseText); // Get the mcu data from the json file request
                                             console.log("Data mcu list");
                                             console.log(mcuDatainfo.Mcu.Pin);  //Get the microcontroller data pin
                                             console.log(mcuDatainfo.Mcu.Core);
                                             console.log(mcuDatainfo.Mcu.Current);
                                             console.log(mcuDatainfo.Mcu.IP);
                                             listmcusPins = mcuDatainfo.Mcu.Pin;
                                             listmcuscommunication = mcuDatainfo.Mcu.IP;
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      // Json parser for classify the power pins and communicaitons pint for connecting with the sensor and other components 
                                             var obj = JSON.parse('{ "Power":["VSS","VDD"], "Boot":["BOOT0","BOOT1"], "I2C":["SDA","SCL"],"SPI":["NSS","SCK","MISO","MOSI"],"UART":["RX","TX"],"USB":["DP","DM"]}');
                                             console.log(obj.Power[0]);
                                             var Pinsfunc = [];
                                             for(var k in obj){ 
                                               console.log(Pinsfunc.push(k)); // Get the function pins for select the function pins selection and connection with the sensor and motor driver board 
                                              }
                                             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                             var i = 0; 
                                             for(i = 0 ; i < listmcusPins.length;i++){
                                                 // Pins auto circuit connection function read the pins type 
                                                 console.log(i,listmcusPins[i]._Name); // Get the pins name 
                                                 console.log(i,listmcusPins[i]._Type); // Get the pins type of the microcontroller compare type of the servo 
                                                 console.log(i,listmcusPins[i]._Instancename); //
                                                 try{
                                                 console.log(i,listmcusPins[i].Signal[0]); // Get the signal pins                                           
                                                 var q = 0; 
                                                 for(q = 0; q < listmcusPins[i].Signal.length;q++){
                                                    
                                                    console.log(listmcusPins[i].Signal[q]._Name);  // Getting the pins function of the microcontroller 
                                                     
                                                 }
                                                }
                                                 catch{
                                                  console.log("Undefines"); // For the undetecte signal  with no connection 
                                                 }   
                                             }
                                             console.log("Pins IO and communication function");
                                             r = 0; 
                                             for(r = 0; r< listmcuscommunication.length;r++)
                                             {
                                                console.log(listmcuscommunication[r]);
                                                console.log(listmcuscommunication[r]._ConfigFile); 
                                                console.log(listmcuscommunication[r]._Name);
                                              }

                                             }
                                             mcuInfo.send()   //Sending the request for the microcontroller    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

       
                }
                if(GenericF1data == GenericF1list[5]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103R4[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R4); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103R4 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R4)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103R4 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R4)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103R4[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103R4[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103R4; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
    
    



               }
               if(GenericF1data == GenericF1list[6]){
                 
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103R6[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R6); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F10R6 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R6)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103R6 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R6)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103R6[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103R6[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103R6; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

       
               }
               if(GenericF1data == GenericF1list[7]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103R8[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R8); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103R8 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R8)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103R8 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R8)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103R8[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103R8[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103R8; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      





               }
               if(GenericF1data == GenericF1list[8]){
                 
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RC[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RC); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RC +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RC)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RC +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RC)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103RC[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103RC[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103RC; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

       
               }
               if(GenericF1data == GenericF1list[9]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RD[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RD); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RD +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RD)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RD +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RD)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103RD[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103RD[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103RD; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      





               }
               if(GenericF1data == GenericF1list[10]){
                 
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RE[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RE +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RE)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RE +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RE)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103C6[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103RE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103RE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

       
               }
               if(GenericF1data == GenericF1list[11]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RF[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RF); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RF +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RF)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RF +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RF)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103RF[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103RF[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103RF; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

 



               }
               if(GenericF1data == GenericF1list[12]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RG[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RG +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RG)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103RG +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RG)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103RG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103RG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103RG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                              
       
               }
               if(GenericF1data == GenericF1list[13]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103T4[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T4); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103T4 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T4)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103T4 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T4)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103T4[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103T4[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103T4; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

  



               }
               if(GenericF1data == GenericF1list[14]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103T6[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T6); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103T6 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T6)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103T6 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T6)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103T6[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103T6[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103T6; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                              
       
               }
               if(GenericF1data == GenericF1list[15]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103TB[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103TB); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103TB +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103TB)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103TB +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103TB)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103TB[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103TB[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103TB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

 



               }
               if(GenericF1data == GenericF1list[16]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103V8[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103V8); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103V8 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103V8)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103V8 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103V8)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103V8[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103V8[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103V8; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                              
       
               }
               if(GenericF1data == GenericF1list[17]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VB[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VB); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VB +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VB)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VB +","+"mcus Spec:"+"\t" + mcuData[3].mcufamily.descriptionsspec.STM32F103VB)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103VB[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103VB[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103VB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

 



               }
               if(GenericF1data == GenericF1list[18]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VC[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VC); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VC +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VC)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VC +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VC)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103VC[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103VC[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103VC; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                              
       
               }
               if(GenericF1data == GenericF1list[19]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VD[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VD); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VD +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VD)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VD +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VD)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103VD[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103VD[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103VD; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      





               }
               if(GenericF1data == GenericF1list[20]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VE[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VE +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VE)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VE +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VE)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103VE[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103VE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103VE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                              
       
               }
               if(GenericF1data == GenericF1list[21]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VF[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VF); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VF +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VF)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VF +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VF)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103VF[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103VF[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103VF; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

               }
               if(GenericF1data == GenericF1list[22]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VG[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VG +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VG)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103VG +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VG)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103VG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103VG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103VG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                              
       
               }
               if(GenericF1data == GenericF1list[23]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZC[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZC); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZC +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZC)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZC +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZC)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103ZC[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103ZC[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103ZC; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

               }
               if(GenericF1data == GenericF1list[24]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZD[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZD); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZD +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZD)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZD +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZD)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103ZD[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103ZD[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103ZD; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

               }
               if(GenericF1data == GenericF1list[25]){
                         
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZE[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZE +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZE)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZE +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZE)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103ZE[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103ZE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103ZE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      




               }
               if(GenericF1data == GenericF1list[26]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZF[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZF); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZF +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZF)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZF +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZF)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103ZF[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103ZF[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103ZF; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

               }
               if(GenericF1data == GenericF1list[27]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZG[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZG +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZG)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZG +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZG)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103ZG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103ZG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103ZG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
               }
               if(GenericF1data == GenericF1list[28]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZET6[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZET6); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZET6 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C6)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.STM32F103ZET6 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZET6)]); 
                                        if(mcuData[4].mcufamily.Specifications.STM32F103ZET6[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103ZET6[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.STM32F103ZET6; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

               }
               if(GenericF1data == GenericF1list[29]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.HYTinySTM32F103TB[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.HYTinySTM32F103TB); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.HYTinySTM32F103TB +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.HYTinySTM32F103TB)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.HYTinySTM32F103TB +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.HYTinySTM32F103TB)]); 
                                        if(mcuData[4].mcufamily.Specifications.HYTinySTM32F103TB[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.HYTinySTM32F103TB[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.HYTinySTM32F103TB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

    



               }
               if(GenericF1data == GenericF1list[30]){
                  var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.MapleSTM32F103CB[0] +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.MapleSTM32F103CB); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.MapleSTM32F103CB +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.MapleSTM32F103CB)); //Alert the spec 
                                        comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + "," +"Packages:" +"\t" + mcuData[4].mcufamily.Specifications.MapleSTM32F103CB +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.MapleSTM32F103CB)]); 
                                        if(mcuData[4].mcufamily.Specifications.MapleSTM32F103CB[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.MapleSTM32F103CB[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[4].mcufamily.Specifications.MapleSTM32F103CB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                              
               }

                        
               });    
      
               //end of the genericSTM32F1
             }
             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                   // GenericSTM32F4
            if(Microcom == microlistdata[5]){
                   console.log("Selected GenericSTM32F4 series");
                   var GenericF4list = ["STM32F407ZG","STM32F407VGT","STM32F407VET","STM32F401CC","STM32F401RCT6","STM32F446RE","STM32F446RC","STM32F423RH","STM32F423CH","STM32F417VG","STM32F417VE","STM32F415RG","STM32F413RH","STM32F413RG","STM32F413CH","STM32F413CG","STM32F412RG","STM32F412RE","STM32F412CG","STM32F412CE","STM32F411RE","STM32F411RC","STM32F411CE","STM32F411CC","STM32F410RB","STM32F410R8","STM32F410CB","STM32F410C8","STM32F407VG","STM32F407VE","STM32F405RG","STM32F401RE","STM32F401RD","STM32F401RC","STM32F401RB","STM32F401CE"];
                   n6 = menu.add(componentsdat,'microdata',["STM32F407ZG","STM32F407VGT","STM32F407VET","STM32F401CC","STM32F401RCT6","STM32F446RE","STM32F446RC","STM32F423RH","STM32F423CH","STM32F417VG","STM32F417VE","STM32F415RG","STM32F413RH","STM32F413RG","STM32F413CH","STM32F413CG","STM32F412RG","STM32F412RE","STM32F412CG","STM32F412CE","STM32F411RE","STM32F411RC","STM32F411CE","STM32F411CC","STM32F410RB","STM32F410R8","STM32F410CB","STM32F410C8","STM32F407VG","STM32F407VE","STM32F405RG","STM32F401RE","STM32F401RD","STM32F401RC","STM32F401RB","STM32F401CE"]).name("GenericF4-Series"); 
                   n6.onChange(function(value){
                   GenericF4data = GenericF4.style.componentsdat = value; //Show the neucleo 
                   console.log(String(GenericF4data)); // Get the Neucleo32 data  
                   alert(String(GenericF4data));
                   if(GenericF4data == GenericF4list[0]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407ZG[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407ZG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407ZG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407ZG)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407ZG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407ZG)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F407ZG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F407ZG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F407ZG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[1]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VGT[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VGT); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VGT +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VGT)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VGT +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VGT)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F407VGT[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F407VGT[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F407VGT; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[2]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VET[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VET); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VET +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VET)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VET +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VET)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F407VET[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F407VET[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F407VET; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[3]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401CC[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CC); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401CC +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CC)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401CC +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CC)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F401CC[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F401CC[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F401CC; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[4]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RCT6[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RCT6); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RCT6 +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RCT6)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RCT6 +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RCT6)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F401RCT6[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F401RCT6[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F401RCT6; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[5]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F446RE[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F446RE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RE)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F446RE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RE)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F446RE[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F446RE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F446RE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[6]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F446RC[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RC); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F446RC +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RC)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F446RC +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RC)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F446RC[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F446RC[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F446RC; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[7]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F423RH[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423RH); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F423RH +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423RH)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F423RH +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423RH)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F423RH[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F423RH[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F423RH; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[8]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F423CH[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423CH); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F423CH +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423CH)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F423CH +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423CH)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F423CH[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F423CH[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F423CH; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[9]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F417VG[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F417VG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VG)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F417VG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VG)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F417VG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F417VG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F417VG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[10]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F417VE[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F417VE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VE)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F417VE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VE)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F417VE[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F417VE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F417VE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[11]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F415RG[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F415RG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F415RG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F415RG)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F415RG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F415RG)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F415RG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F415RG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F407ZG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[12]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413RH[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RH); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413RH +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RH)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413RH +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RH)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F413RH[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F413RH[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F413RH; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[13]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413RG[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413RG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RG)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413RG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RG)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F413RG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F413RG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F413RG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[14]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413CH[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CH); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413CH +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CH)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413CH +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CH)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F413CH[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F413CH[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F413CH; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[15]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413CG[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413CG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CG)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F413CG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CG)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F413CG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F413CG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F413CG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[16]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412RG[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412RG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RG)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412RG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RG)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F412RG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F412RG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F412RG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[17]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412RE[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412RE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RE)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412RE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RE)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F412RE[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F412RE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F412RE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[18]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412CG[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412CG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CG)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412CG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CG)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F412CG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F412CG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F412CG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[19]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412CE[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412CE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CE)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F412CE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CE)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F412CE[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F412CE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F412CE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[20]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411RE[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411RE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RE)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411RE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RE)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F411RE[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F411RE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F411RE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[21]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411RC[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RC); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411RC +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RC)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411RC +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RC)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F411RC[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F411RC[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F411RC; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[22]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411CE[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411CE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CE)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411CE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CE)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F411CE[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F411CE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F411CE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[23]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411CC[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CC); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411CC +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CC)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F411CC +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CC)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F411CC[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F411CC[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F411CC; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[24]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410RB[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410RB); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410RB +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410RB)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410RB +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410RB)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F410RB[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F410RB[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F410RB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[25]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410R8[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F4410R8); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410R8 +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410R8)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410R8 +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410R8)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F410R8[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F410R8[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F410R8; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[26]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410CB[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410CB); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410CB +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410CB)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410CB +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410CB)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F410CB[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F410CB[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F410CB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[27]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410C8[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410C8); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410C8 +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410C8)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F410C8 +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410C8)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F410C8[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F410C8[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F410C8; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[28]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VG[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VG)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VG)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F407VG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F407VG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F407VG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[29]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VE[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VE)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F407VE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VE)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F407VE[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F407VE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F407VE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[30]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F405RG[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F405RG); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F405RG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F405RG)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F405RG +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F405RG)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F405RG[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F405RG[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F405RG; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[31]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RE[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RE)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RE)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F401RE[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F401RE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F401RE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[32]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RD[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RD); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RD +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RD)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RD +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RD)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F401RD[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F401RD[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F401RD; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[33]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RC[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RC); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RC +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RC)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RC +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RC)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F401RC[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F401RC[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F401RC; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[34]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RB[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RB); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RB +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RB)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401RB +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RB)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F401RB[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F401RB[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F401RB; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
                  if(GenericF4data == GenericF4list[35]){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401CE[0] +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CE); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401CE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CE)); //Alert the spec 
                                        comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + "," +"Packages:" +"\t" + mcuData[5].mcufamily.Specifications.STM32F401CE +","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CE)]); 
                                        if(mcuData[5].mcufamily.Specifications.STM32F401CE[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[5].mcufamily.Specifications.STM32F401CE[6].split(" ")[1])); // Get the status alert on the function 
                                                     //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                                                     let packages3ddata = mcuData[5].mcufamily.Specifications.STM32F401CE; // Split the comma if found 
                                                      //extracting list packages data in the list 
                                                     var qr = 0; 
                                                     for(qr = 0; qr <= packages3ddata[0].split(',').length; qr++){
                                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(packages3ddata[0].split(',')[qr-1])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                                     modelmcus = meshes[0]; // Get the full model part to put into the position where the part should assembly               
                                                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                      //List of the position where the part should live 
                                                     // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical                          
                                                     modelmcus.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                                     modelmcus.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                                     modelmcus.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                                     modelmcus.rotation.z = Math.PI*0.25; //Model mesh roation 
                                                     modelmcus.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                                     var angle = 0;
                                                     scene.registerBeforeRender(function(){
                                                     modelmcus.rotation.y = angle;
                                                     angle +=0.01;
                                                 });
                                                
                                                });
                                             }    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
               });    
               //end of the genericSTM32F4
             }
             //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
              
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom);
                    remover.onChange(function(){
                       menu.remove(micro);
                       menu.remove(remover);
                       if(Microcom == microlistdata[0]){ 
                           menu.remove(n1);
                       }
                       if(Microcom == microlistdata[1]){
                           menu.remove(n2);
                       }
                       if(Microcom == microlistdata[2]){
                           menu.remove(n3);
                       }
                       if(Microcom == microlistdata[3]){
                           menu.remove(n4);
                       }
                       if(Microcom == microlistdata[4]){
                           menu.remove(n5);
                       }
                       if(Microcom == microlistdata[5]){
                           menu.remove(n6);
                       }
                       menu.remove(inputmcu);                 
                       modelmcus.setEnabled(false);
                       modelmcus.dispose();
             }); // Get the feed back data s
          });
                    
                  }
                  //var remover = menu.add(removepartsmcu,'add').name(funccom);
                  //Actuator and driver
                  if(funccom == Functiondata[2]) { 
                     var icdt = menu.add(componentsdat,'ic',['AA51880','Non-Select']).name("Actuators driver ic");     // Get the data from the AJAX 
                     icdt.setValue("Non-Select");
                     icdt.onChange(function(value){
                     ICcom = ICdataset.style.componentsdat = value; 
                           console.log(ICcom);  // Get list data output 
                           comvis.push(["Actuator driver IC:"+String(ICcom)]); // Gettting the driver ic into the  
      
                     });
                     var inputic = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                           // Add the model of name from the matcom here  
                           console.log("ActuatorDriverIC"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputic.object["Amount"]+","+String(ICcom)); // Get the data mesh input from the text input
                           comvis.push("ActuatorDriverIC"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputic.object["Amount"]+","+String(ICcom)); // push the json file output selection to the client software
                           
                           // Do the function clones multiple models here 
                           BABYLON.SceneLoader.ImportMesh("","static/" ,String(ICcom)+".glb", scene, function (meshes, particleSystems, skeletons) {
                                      modelactuator = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                     
                                      modelactuator.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                      modelactuator.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                      modelactuator.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                      modelactuator.rotation.z = Math.PI*0.25; //Model mesh roation 
                                      modelactuator.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                      var angle = 0;
                                      scene.registerBeforeRender(function(){
                                      modelactuator.rotation.y = angle;
                                      angle +=0.01;
                                      });
                           });
                     });
                     var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                      remover.onChange(function(){
                       menu.remove(icdt); // Get the 
                       menu.remove(remover);
                       menu.remove(inputic);
                       modelactuator.setEnabled(false);
                       modelactuator.dispose();
                    }); // Get the feed back data 
                  }
                   // Image sensor 
                  if(funccom == Functiondata[3]){
                     var imagesense = menu.add(componentsdat,'Imagesensor',['2MPixel','3MPixel','6Mpixel','8MPixel']).name("Image sensor");     // Get the data from the AJAX 
                     imagesense.onChange(function(value){
                     Imagecom = Imagedataset.style.componentsdat = value; 
                              console.log(Imagecom);  // Get list data output 
                              // Do the function clones multiple models here 
                              
                     });
                     inputimagesensor = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                            // Add the model of name from the matcom here  
                            console.log("Imagesensor"+":"+mockingmodel+","+"Position"+":"+addPosition+","+"Amount"+":"+inputimagesensor.object["Amount"]+","+String(Imagecom)); // Get the data mesh input from the text input
                            // Do the function clones multiple models here 
                            data_com = "Imagesensor"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputimagesensor.object["Amount"]+","+String(Imagecom);            
                            console.log("Imagesensor"+":"+mockingmodel+","+"Position"+","+addPosition+","+"Amount"+","+inputimagesensor.object["Amount"]+","+String(Imagecom)); // Getting the data to display on the json file 
                            comvis.push(data_com); // 
                            BABYLON.SceneLoader.ImportMesh("","static/" ,String(Imagecom)+".glb", scene, function (meshes, particleSystems, skeletons) {
                                      modelimage = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                      
                                      modelimage.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                      modelimage.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                      modelimage.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                      modelimage.rotation.z = Math.PI*0.25; //Model mesh roation 
                                      modelimage.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                      var angle = 0;
                                      scene.registerBeforeRender(function(){
                                      modelimage.rotation.y = angle;
                                      angle +=0.01;
                                      });
                                      
                           });
                     });
                     var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                       remover.onChange(function(){
                       menu.remove(imagesense); // Get the 
                       menu.remove(remover);
                       menu.remove(inputimagesensor);
                       modelimage.setEnabled(false);
                       modelimage.dispose();
                    }); // Get the feed back data 
                  }
                   //Computer onboard 
                  if(funccom == Functiondata[4]){
                     var computeronb = menu.add(componentsdat,'Computeronboard',['RaspberryPiZeroW','RaspberryPi3B','Rasberry pi Model 4 B+','BeagleBoneBlack','BeagleBoneBlue','Jetsonnano','JetsonNXXavier','Non-Select']).name("Computer on-board");     // Get the data from the AJAX 
                     computeronb.setValue("Non-Select")
                     computeronb.onChange(function(value){
                     Computecom = Computedataset.style.componentsdat = value; 
                           console.log(Computecom);  // Get list data output 
                           // Get the position of the pickable mesh to put the model on the top of each mesh position to be ready to assembly the product
                           
                     });
                     inputcompute = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                            // Add the model of name from the matcom here  
                            console.log("Computeronboard"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputcompute.object["Amount"]+","+String(Computecom)); // Get the data mesh input from the text input
                            comvis.push("Computeronboard"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputcompute.object["Amount"]+","+String(Computecom)); 
                                  
                            //Do the function clones multiple models here 
                            BABYLON.SceneLoader.ImportMesh("","static/" ,String(Computecom)+".glb", scene, function (meshes, particleSystems, skeletons) {
                                      modelsbc = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                     
                                      modelsbc.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                      modelsbc.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                      modelsbc.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                      modelsbc.rotation.z = Math.PI*0.25; //Model mesh roation 
                                      modelsbc.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                      var angle = 0;
                                      scene.registerBeforeRender(function(){
                                      modelsbc.rotation.y = angle;
                                      angle +=0.01;
                                      });
                           });
                     });
                     var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                       remover.onChange(function(){
                       menu.remove(computeronb); // Get the 
                       menu.remove(remover);
                       menu.remove(inputcompute);
                       modelacous.setEnabled(false);
                       modelacous.dispose();
                    }); // Get the feed back data 
                    }
                   //Sensor array
                  if(funccom == Functiondata[5]){
                     listSensors = ['Physicssensor','Biosensor','Chemicalsensor']; // List sensor for the 
                     var Sensearrays = menu.add(componentsdat,'Sensearray',['Physicssensor','Biosensor','Chemicalsensor','Non-Select']).name("Sensors");     // Get the data from the AJAX 
                     Sensearrays.setValue("Non-Select");
                     Sensearrays.onChange(function(value){
                     Sensecom = Sensedataset.style.componentsdat = value; 
                           console.log(Sensecom);  // Get list data output 
                           // Get the position of the pickable mesh to put the model on the top of each mesh position to be ready to assembly the product

                     
                   
                   if(Sensecom == listSensors[0]){
                           
                            //Sensor request for the communication and pins conneciton 
                           var sensorInfo = new XMLHttpRequest(); //
                           var sensorDatainfo;
                           sensorInfo.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/Sensor_specification/main/sensorspec.json'); // Get the Json data of the micro controller specification data structure
                           sensorInfo.onload = function() {
                           var sensorDatainfo = JSON.parse(sensorInfo.responseText); // Get the mcu data from the json file request 
                                             
                           console.log(sensorDatainfo.sensor.PhysicsSensor.IMU); // Get the sensor data list communication and 
                           //console.log(sensorDatainfo.sensor.BioSensor.Heartrate); // Get the heartrate sensor for the bio sensor 
                           //console.log(sensorDatainfo.sensor.ChemicalSensor.CO2sensor); //Get the chemical sensor data 
                           var sensorpart = [];
                           for(var s in sensorDatainfo.sensor.PhysicsSensor) sensorpart.push(s);
                           console.log(sensorDatainfo.sensor.PhysicsSensor[s]); // Get the list type of the sensor parts from the key 
                           //Get the list option sensor from here       
                           var sensorpart = menu.add(componentsdat,'Sensorpartsdata',sensorpart).name("Sensor-parts");
                           sensorpart.onChange(function(value){
                           sensorpart = Sensordatapart.style.componentsdat = value;
                                 console.log(sensorpart); //Setting the sensor specification from the selected sensor type 
                                 console.log(sensorDatainfo.sensor.PhysicsSensor[sensorpart]); //Getting the sensor datainput
                                 var sensorSpec = [];
                                 for(var q in sensorDatainfo.sensor.PhysicsSensor[sensorpart]) sensorSpec.push(q); // Get the specification spec  
                                 var sensorSpecs = menu.add(componentsdat,'SenseSpec',sensorSpec); 
                                 sensorSpecs.onChange(function(value){
                                 sensorSpecs = SensorSpecpart.style.componentsdat = value; //Sensor spec 
                                            console.log(sensorSpecs);
                                            inputsense = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                                            // Add the model of name from the matcom here  
                                            console.log("SensorArray"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputsense.object["Amount"]+","+String(Sensecom)); // Get the data mesh input from the text input
                                            comvis.push("SensorArray"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputsense.object["Amount"]+","+String(Sensecom));
                                            // Do the function clones multiple models here 
                                            BABYLON.SceneLoader.ImportMesh("","static/" ,String(sensorSpecs)+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                            modelacous = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                           //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                          //List of the position where the part should live 
                                          // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                            modelacous.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                            modelacous.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                            modelacous.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                            modelacous.rotation.z = Math.PI*0.25; //Model mesh roation 
                                            modelacous.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                            var angle = 0;
                                            scene.registerBeforeRender(function(){
                                            modelacous.rotation.y = angle;
                                            angle +=0.01;
                                           });
                                        });
                                        BABYLON.SceneLoader.ImportMesh("","static/" ,String(sensorSpecs)+".glb", scene, function (meshes, particleSystems, skeletons) {
                                            modelacous = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                           //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                          //List of the position where the part should live 
                                          // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                            modelacous.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                            modelacous.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                            modelacous.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                            modelacous.rotation.z = Math.PI*0.25; //Model mesh roation 
                                            modelacous.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                            var angle = 0;
                                            scene.registerBeforeRender(function(){
                                            modelacous.rotation.y = angle;
                                            angle +=0.01;
                                           });
                                        });
                                   });
                                   var communicationsense = sensorDatainfo.sensor.PhysicsSensor[sensorpart][sensorSpecs]['Communicationspins'];
                                   var commusense = []; 
                                   for(var w in communicationsense) commusense.push(w);
                                   var cpout = menu.add(componentsdat,'SenseCommunic',commusense).name('Communication pins');
                                   cpout.onChange(function(value){
                                   cpout = Sensecompin.style.componentsdat = value; // Sensor communication pins 
                                         console.log(cpout);
                                         console.log(communicationsense[cpout]); //Get the pins for connection 
                                         var specoutput = sensorDatainfo.sensor.PhysicsSensor[sensorpart][sensorSpecs]['Specifications']; // Get the spec output 
                                            //Get the result of the spec and com 
                                         console.log(["Sensor:"+sensorpart+","+"Specifications:"+specoutput+","+"Communicationspins:"+communicationsense[cpout]]);   
                                         comvis.push(["Sensor:"+sensorpart+","+"Specifications:"+specoutput+","+"Communicationspins:"+communicationsense[cpout]]);      
                                   });
                                   var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                                     remover.onChange(function(){
                                     menu.remove(Sensearrays); 
                                     menu.remove(remover);
                                     menu.remove(inputsense); 
                                     modelacous.setEnabled(false);
                                     modelacous.dispose();
                                   }); // Get the feed back data 
                                  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                       
                                 });
                           });
                           }
                           sensorInfo.send();
                         
                          
                   } 
                   if(Sensecom == listSensors[1]){
                                  //Sensor request for the communication and pins conneciton 
                           var sensorInfo = new XMLHttpRequest(); //
                           var sensorDatainfo;
                           sensorInfo.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/Sensor_specification/main/sensorspec.json'); // Get the Json data of the micro controller specification data structure
                           sensorInfo.onload = function() {
                           var sensorDatainfo = JSON.parse(sensorInfo.responseText); // Get the mcu data from the json file request 
                                             
                           //console.log(sensorDatainfo.sensor.PhysicsSensor.IMU); // Get the sensor data list communication and 
                           console.log(sensorDatainfo.sensor.BioSensor.Heartrate); // Get the heartrate sensor for the bio sensor 
                           //console.log(sensorDatainfo.sensor.ChemicalSensor.CO2sensor); //Get the chemical sensor data 
                           var sensorpart = [];
                           for(var s in sensorDatainfo.sensor.BioSensor) sensorpart.push(s);
                           console.log(sensorDatainfo.sensor.BioSensor[s]); // Get the list type of the sensor parts from the key 
                           //Get the list option sensor from here       
                           var sensorpart = menu.add(componentsdat,'Sensorpartsdata',sensorpart).name("Sensor-parts");
                           sensorpart.onChange(function(value){
                           sensorpart = Sensordatapart.style.componentsdat = value;
                                 console.log(sensorpart); //Setting the sensor specification from the selected sensor type 
                                 console.log(sensorDatainfo.sensor.BioSensor[sensorpart]); //Getting the sensor datainput
                                 var sensorSpec = [];
                                 for(var q in sensorDatainfo.sensor.BioSensor[sensorpart]) sensorSpec.push(q); // Get the specification spec  
                                 var sensorSpecs = menu.add(componentsdat,'SenseSpec',sensorSpec); 
                                 sensorSpecs.onChange(function(value){
                                 sensorSpecs = SensorSpecpart.style.componentsdat = value; //Sensor spec 
                                            console.log(sensorSpecs);
                                            inputsense = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                                            // Add the model of name from the matcom here  
                                            console.log("SensorArray"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputsense.object["Amount"]+","+String(Sensecom)); // Get the data mesh input from the text input
                                            comvis.push("SensorArray"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputsense.object["Amount"]+","+String(Sensecom)); //Getting the part push 
                                            // Do the function clones multiple models here 
                                            BABYLON.SceneLoader.ImportMesh("","static/" ,String(sensorSpecs)+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                            modelacous = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                           //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                          //List of the position where the part should live 
                                          // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                            modelacous.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                            modelacous.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                            modelacous.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                            modelacous.rotation.z = Math.PI*0.25; //Model mesh roation 
                                            modelacous.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                            var angle = 0;
                                            scene.registerBeforeRender(function(){
                                            modelacous.rotation.y = angle;
                                            angle +=0.01;
                                           });
                                        });
                                   });
                                   var communicationsense = sensorDatainfo.sensor.BioSensor[sensorpart][sensorSpecs]['Communicationspins'];
                                   var commusense = []; 
                                   for(var w in communicationsense) commusense.push(w);
                                   var cpout = menu.add(componentsdat,'SenseCommunic',commusense).name('Communication pins');
                                   cpout.onChange(function(value){
                                   cpout = Sensecompin.style.componentsdat = value; // Sensor communication pins 
                                         console.log(cpout);
                                         var specoutput = sensorDatainfo.sensor.BioSensor[sensorpart][sensorSpecs]['Specifications']; // Get the spec output 
                                               //Get the result of the spec and com 
                                         console.log(["Sensor:"+sensorpart+","+"Specifications:"+specoutput+","+"Communicationspins:"+communicationsense[cpout]]);   
                                         comvis.push(["Sensor:"+sensorpart+","+"Specifications:"+specoutput+","+"Communicationspins:"+communicationsense[cpout]]);      

                                   });
                                   var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                                     remover.onChange(function(){
                                     menu.remove(Sensearrays); 
                                     menu.remove(remover);
                                     menu.remove(inputsense); 
                                     modelacous.setEnabled(false);
                                     modelacous.dispose();
                                   }); // Get the feed back data 
                                           
                                 });
                           });
                             
                           }
                           sensorInfo.send();
                          
                  
                   }
                   if(Sensecom == listSensors[2]){
                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                       //Request the sensor part data 
                       //Sensor request for the communication and pins conneciton 
                       var sensorInfo = new XMLHttpRequest(); //
                           var sensorDatainfo;
                           sensorInfo.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/Sensor_specification/main/sensorspec.json'); // Get the Json data of the micro controller specification data structure
                           sensorInfo.onload = function() {
                           var sensorDatainfo = JSON.parse(sensorInfo.responseText); // Get the mcu data from the json file request 
                                             
                           //console.log(sensorDatainfo.sensor.PhysicsSensor.IMU); // Get the sensor data list communication and 
                           //console.log(sensorDatainfo.sensor.BioSensor.Heartrate); // Get the heartrate sensor for the bio sensor 
                           console.log(sensorDatainfo.sensor.ChemicalSensor.CO2sensor); //Get the chemical sensor data 
                           var sensorpart = [];
                           for(var s in sensorDatainfo.sensor.ChemicalSensor) sensorpart.push(s);
                           console.log(sensorDatainfo.sensor.ChemicalSensor[s]); // Get the list type of the sensor parts from the key 
                           //Get the list option sensor from here       
                           var sensorpart = menu.add(componentsdat,'Sensorpartsdata',sensorpart).name("Sensor-parts");
                           sensorpart.onChange(function(value){
                           sensorpart = Sensordatapart.style.componentsdat = value;
                                 console.log(sensorpart); //Setting the sensor specification from the selected sensor type 
                                 console.log(sensorDatainfo.sensor.ChemicalSensor[sensorpart]); //Getting the sensor datainput
                                 var sensorSpec = [];
                                 for(var q in sensorDatainfo.sensor.ChemicalSensor[sensorpart]) sensorSpec.push(q); // Get the specification spec  
                                 var sensorSpecs = menu.add(componentsdat,'SenseSpec',sensorSpec); 
                                 sensorSpecs.onChange(function(value){
                                 sensorSpecs = SensorSpecpart.style.componentsdat = value; //Sensor spec 
                                            console.log(sensorSpecs);
                                            inputsense = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                                            // Add the model of name from the matcom here  
                                            console.log("SensorArray"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputsense.object["Amount"]+","+String(Sensecom)); // Get the data mesh input from the text input
                                            comvis.push("SensorArray"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputsense.object["Amount"]+","+String(Sensecom));
                                            // Do the function clones multiple models here 
                                            BABYLON.SceneLoader.ImportMesh("","static/" ,String(sensorSpecs)+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                            modelacous = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                           //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                          //List of the position where the part should live 
                                          // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                            modelacous.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                            modelacous.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                            modelacous.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                            modelacous.rotation.z = Math.PI*0.25; //Model mesh roation 
                                            modelacous.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                            var angle = 0;
                                            scene.registerBeforeRender(function(){
                                            modelacous.rotation.y = angle;
                                            angle +=0.01;
                                           });
                                        });
                                   });
                                   var communicationsense = sensorDatainfo.sensor.ChemicalSensor[sensorpart][sensorSpecs]['Communicationspins'];
                                   var commusense = []; 
                                   for(var w in communicationsense) commusense.push(w);
                                   var cpout = menu.add(componentsdat,'SenseCommunic',commusense).name('Communication pins');
                                   cpout.onChange(function(value){
                                   cpout = Sensecompin.style.componentsdat = value; // Sensor communication pins 
                                         console.log(cpout);
                                         var specoutput = sensorDatainfo.sensor.BioSensor[sensorpart][sensorSpecs]['Specifications']; // Get the spec output 
                                               //Get the result of the spec and com 
                                         console.log(["Sensor:"+sensorpart+","+"Specifications:"+specoutput+","+"Communicationspins:"+communicationsense[cpout]]);   
                                         comvis.push(["Sensor:"+sensorpart+","+"Specifications:"+specoutput+","+"Communicationspins:"+communicationsense[cpout]]);      

                                   });
                                   var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                                     remover.onChange(function(){
                                     menu.remove(Sensearrays); 
                                     menu.remove(remover);
                                     menu.remove(inputsense); 
                                     modelacous.setEnabled(false);
                                     modelacous.dispose();
                                    }); // Get the feed back data 
                              
                                          
                                 });
                           });
                           }
                           sensorInfo.send();
                          
                     //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                           
                   }
                    
                   });
                   
                  }
                  //Acoustic amplifier Class -D 
                  if(funccom == Functiondata[6]){
                     var Ampdata = menu.add(componentsdat,'AcousticAmp',['PCM6240-Q1','TLV320ADC5140','PCM1808','TAS5825','TAS2770','OPA1692','Non-Select']).name("Acoustic amplifier");     // Get the data from the AJAX 
                     Ampdata.setValue("Non-Select");
                     Ampdata.onChange(function(value){
                     Ampcom = Ampdataset.style.componentsdat = value; 
                           console.log(Ampcom);  // Get list data output 
                           // Get the position of the pickable mesh to put the model on the top of each mesh position to be ready to assembly the product

                     });
                     inputamp = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                           // Add the model of name from the matcom here  
                            console.log("AmplifiermoduleIC"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputamp.object["Amount"]+","+String(Ampcom)); // Get the data mesh input from the text input
                            comvis.push("AmplifiermoduleIC"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputamp.object["Amount"]+","+String(Ampcom));
                            // Do the function clones multiple models here 
                            BABYLON.SceneLoader.ImportMesh("","static/" ,String(Ampcom)+".glb", scene, function (meshes, particleSystems, skeletons) {
                                      modelacousamp = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                     
                                      modelacous.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                      modelacous.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                      modelacous.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                      modelacous.rotation.z = Math.PI*0.25; //Model mesh roation 
                                      modelacous.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                      var angle = 0;
                                      scene.registerBeforeRender(function(){
                                      modelacousamp.rotation.y = angle;
                                      angle +=0.01;
                                      });
                           });
                     });
                     var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                       remover.onChange(function(){
                       menu.remove(Ampdata); // Get the 
                       menu.remove(remover);
                       menu.remove(inputamp); // Remove the input amplifier
                       modelacous.setEnabled(false);
                       modelacous.dispose();
                    }); // Get the feed back data 
                  }
                  //Navigation sensor 
                  if(funccom == Functiondata[7]){
                     var Navisys = menu.add(componentsdat,'Navigationsense',['GPS','Lidar','Radar','Multi-camera slam','Non-Select']).name("Navigation sensor");     // Get the data from the AJAX 
                     Navisys.setValue("Non-Select");
                     Navisys.onChange(function(value){
                     Navicom = Navidataset.style.componentsdat = value; 
                           console.log(Navicom);  // Get  list data output 
                           // Get the position of the pickable mesh to put the model on the top of each mesh position to be ready to assembly the product

                     });
                     inputnavi = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                           // Add the model of name from the matcom here  
                            console.log("Navigationsensor"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputnavi.object["Amount"]+","+String(Navicom)); // Get the data mesh input from the text input
                            comvis.push("Navigationsensor"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputnavi.object["Amount"]+","+String(Navicom));
                            // Do the function clones multiple models here 
                            BABYLON.SceneLoader.ImportMesh("","static/" ,String(Navicom)+".glb", scene, function (meshes, particleSystems, skeletons) {
                                      modelnavigation = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                     
                                      modelacous.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                      modelacous.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                      modelacous.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                      modelacous.rotation.z = Math.PI*0.25; //Model mesh roation 
                                      modelacous.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                      var angle = 0;
                                      scene.registerBeforeRender(function(){
                                      modelacous.rotation.y = angle;
                                      angle +=0.01;
                                      });
                           });
                     });
                     var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                       remover.onChange(function(){
                       menu.remove(Navisys); // Get the 
                       menu.remove(remover);
                       menu.remove(inputnavi); 
                       modelacous.setEnabled(false);
                       modelacous.dispose();
                    }); // Get the feed back data 

                  }
                  //Cellular LTE module
                  if(funccom == Functiondata[8]){
                     var Cellular = menu.add(componentsdat,'CellularLTEmod',['QuectelEC21-AUTL','QuectelBC66','QuectelM85','Non-Select']).name("Cellular LTE module"); 
                         // Get the data from the AJAX
                     Cellular.setValue("Non-Select");      
                     Cellular.onChange(function(value){
                     Cellucom = Celludataset.style.componentsdat = value; 
                           console.log(Cellucom);  // Get list data output 
                           // Get the position of the pickable mesh to put the model on the top of each mesh position to be ready to assembly the product

                     });
                     var inputCellular = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                            // Add the model of name from the matcom here  
                            console.log("CellularLTEmod"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputCellular.object["Amount"]+","+String(Cellucom)); // Get the data mesh input from the text input
                            comvis.push("CellularLTEmod"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputCellular.object["Amount"]+","+String(Cellucom));
                            
                            // Do the function clones multiple models here 
                            BABYLON.SceneLoader.ImportMesh("","static/" ,String(Cellucom)+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                      modelacous = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                     
                                      modelacous.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                      modelacous.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                      modelacous.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                      modelacous.rotation.z = Math.PI*0.25; //Model mesh roation 
                                      modelacous.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                      var angle = 0;
                                      scene.registerBeforeRender(function(){
                                      modelacous.rotation.y = angle;
                                      angle +=0.01;
                                      });
                           }); 
                     });
                     var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                       remover.onChange(function(){
                       menu.remove(Cellular);  
                       menu.remove(remover);
                       menu.remove(inputCellular);
                       modelacous.setEnabled(false);
                       modelacous.dispose();
                    }); // Get the feed back data 
                  }
                  //Battery 
                  if(funccom == Functiondata[9]){
                     var Batteryactive = menu.add(componentsdat,'Batterylist',['Liion','LiPo','LiPo4','SuperCap','Non-Select']).name("Battery");     // Get the data from the AJAX 
                     Batteryactive.setValue("Non-Select");
                     Batteryactive.onChange(function(value){
                     Powercom = Batterydatsets.style.powersystem = value; 
                           console.log(Powercom);  // Get list data output 
                           // Get the position of the pickable mesh to put the model on the top of each mesh position to be ready to assembly the product

                     });

                    
                     inputBattery = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                           // Add the model of name from the matcom here  
                            console.log("Battery"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputBattery.object["Amount"]+","+String(Powercom)); // Get the data mesh input from the text input
                            // Do the function clones multiple models here 
                            comvis.push("Battery"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputBattery.object["Amount"]+","+String(Powercom));
                            
                             BABYLON.SceneLoader.ImportMesh("","static/" ,String(Powercom)+".glb", scene, function (meshes, particleSystems, skeletons) {
                                      modelbattery = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                     
                                      modelbattery.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                      modelbattery.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                      modelbattery.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                      modelbattery.rotation.z = Math.PI*0.25; //Model mesh roation 
                                      modelbattery.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                      var angle = 0;
                                      scene.registerBeforeRender(function(){
                                      modelbattery.rotation.y = angle;
                                      angle +=0.01;
                                    });
                           });
                        
                         
                      var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                       remover.onChange(function(){
                       menu.remove(Batteryactive); // Get the 
                       menu.remove(remover);
                       menu.remove(inputBattery);
                       modelbattery.setEnabled(false);
                       modelbattery.dispose();
                    }); // Get the feed back data 
                  
                  }
               )};
                  //BMS module 
                  if(funccom == Functiondata[10]){
                     var BMsys = menu.add(componentsdat,'BMSmod',['BQ25616','BQ25611D','BQ21061','BQ25619','BQ25125','BQ25886','Non-Select']).name("Acoustic amplifier");     // Get the data from the AJAX 
                     BMsys.setValue("Non-Select");
                     BMsys.onChange(function(value){
                     BMScom = BMSdataset.style.powersystem = value; 
                           console.log(BMScom);  // Get list data output 
                           // Get the position of the pickable mesh to put the model on the top of each mesh position to be ready to assembly the product

                     });
                     inputBMS = menu.add(paramsinput,"Amount").onFinishChange(function (value){
                           // Add the model of name from the matcom here  
                           console.log("BMSmodule"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputBMS.object["Amount"]+","+String(BMScom)); // Get the data mesh input from the text input
                           comvis.push("BMSmodule"+","+mockingmodel+","+"Position"+","+addPosition+":"+"Amount"+","+inputBMS.object["Amount"]+","+String(BMScom));
                           // Do the function clones multiple models here 
                            BABYLON.SceneLoader.ImportMesh("","static/" ,String(BMScom)+".glb", scene, function (meshes, particleSystems, skeletons) {
                                      modelacous = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                     
                                      modelacous.position.x = pickResult.pickedPoint.x;           // meshes[21].position.x  
                                      modelacous.position.y = pickResult.pickedPoint.y;      //meshes[21].position.y
                                      modelacous.position.z = pickResult.pickedPoint.z;   //meshes[21].position.z
                                      modelacous.rotation.z = Math.PI*0.25; //Model mesh roation 
                                      modelacous.rotation = new BABYLON.Vector3(Math.PI, Math.PI/2+0.03, Math.PI); // Get the model rotation for the position control in the function 
                                      var angle = 0;
                                      scene.registerBeforeRender(function(){
                                      modelacous.rotation.y = angle;
                                      angle +=0.01;
                                      });
                           });
                     });
                     var remover = menu.add(removepartsmcu,'add').name("Remove"+"\t"+funccom); 
                       remover.onChange(function(){
                       menu.remove(BMsys); 
                       menu.remove(remover);
                       menu.remove(inputBMS);
                       modelacous.setEnabled(false);
                       modelacous.dispose();
                    }); // Get the feed back data 
                   }
                  });
                    var comdat =  menu.add(componentsdat,'positioninput',addPosition).name('Position');
                    comdat.onChange(function(value){
                        var compodata  = compodota.style.componentsdat = value; 
                        console.log(compodata); //component data 
                                        

                    });                   
                 
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                    // Mesh picker image and the color of the mesh display 
                    scene.render();
                    var mat = new BABYLON.StandardMaterial("mat", scene);
                    mat.diffuseColor = BABYLON.Color3.Blue();
                    scene.constantlyUpdateMeshUnderPointer = true;
                    
	                 scene.onPointerMove = function (evt, pickingInfo) {
	                 scene.meshes.forEach(function (m) {
		           	  m.material = null;
		              });
             		if (pickingInfo.pickedMesh) {
                       pickingInfo.pickedMesh.material = mat;
                       //Get the label color display function for the part picking 
                       
	            	}
	              }
                 //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                            //GUI mesh point  for control the mesg part materials function     
                  
                
                 

                 //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                }

            };
     
            

                                    //meshes[40].position.x =+0.1; // side way coder with SB attachable on the model system 
                                    //meshes[42].position.x =+0.1; 
                                    //meshes[43].position.x = +0.1; 
                                    //meshes[45].position.x = +0.1; // Right side MCU cover 
                                    //meshes[48].position.x =+ 0.1; // Left side MCU cover
                                    //meshes[51].position.x =+ 0.1; // Right back leg foot 
                                    //meshes[53].position.x =+ 0.1;// Right leg main joint integration
                                   // meshes[54].position.x =+0.1  //Right front leg connector 
                                    //meshes[55].position.x = +0.1; // Right front leg  side cover and axis head 
                                    //meshes[56].position.x =+ 0.1; //Right front leg axis cover 
                                    //meshes[57].position.x =+ 0.1; //Roght front leg servo cover 
                                    //meshes[58].position.x =+ 0.1; //Right front leg joint cover with axis 
                           // meshes[59].position.y =-0.02; // bottom at the back 
                                    //meshes[60].position.x =+0.02; // Left nack foot 
                                   // meshes[61].position.x =-0.02 // Left last terminal leg  
                                    //meshes[62].position.x =- 0.02; // Second connector terminal left leg
                                    //meshes[63].position.x =- 0.02; // Left hip servo joint connector                                      
                                    //meshes[64].position.x =- 0.02; //Left hip joint connector 
                                    //meshes[65].position.x =- 0.02; //Left back leg first connector 
                                   // meshes[66].position.x =- 0.02; // Left hip integration joint 
                                   // meshes[67].position.x =+ 0.02; //joint innner with axis head at the hib joint 
                                   //meshes[68].position.x =- 0.1; // seccond joint cover connection at the hip first connector
                                    //meshes[69].position.x =+ 0.1; // Right back foot
                                    //meshes[70].position.x =+ 0.1; //right final leg 
                                    //meshes[71].position.x =+ 0.1; //Seccond joint of the terminal leg joint 
                                    //meshes[72].position.x =+ 0.1; // Right back leg  
                                    //meshes[73].position.x =+ 0.1; // Left hip integration joint 
                                    //meshes[74].position.x =+ 0.1; //Left leg servo connection 
                                    //meshes[75].position.x =+ 0.1; //Right back leg joint cover axis 
                                    //meshes[76].position.x =+ 0.1; //Right back leg first cover connector with axis head 
                                    //meshes[77].position.x =+ 0.1; //Seccond jointback leg connector 
                                    console.log(scene.transformNodes[20].name); 
                                    //model1.position.x =+ 0.4;
                                    //meshes[52].rotation.x = new BABYLON.Vector3(Math.PI/3, Math.PI/2, Math.PI/2);
                                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.
                                        // Adding the optic sensors camera and other object avoidence and mapping sensor like lidart 
                                         // Get the optic sensor list function 
                                       BABYLON.SceneLoader.ImportMesh("","static/" ,String(Opticsensorlist[0])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                       var modelCamera  = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                      modelCamera.position.x =+0.455           // meshes[21].position.x  
                                      modelCamera.position.y =+0.26        //meshes[21].position.y
                                      modelCamera.position.z =+0.135  //meshes[21].position.z
                                      modelCamera.rotation.z = Math.PI*0.25; // Model mesh roation 
                                      modelCamera.rotation = new BABYLON.Vector3(-Math.PI/2 - 0.01, Math.PI-0.7, Math.PI/2+0.05); // Get the model rotation for the position control in the function 
                                      
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>                                   
                                    
                                    });
                                    BABYLON.SceneLoader.ImportMesh("","static/" ,String(Sensorslist[3])+".gltf", scene, function (meshes, particleSystems, skeletons) {
                                       var modelCamera  = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                                      modelCamera.position.x =+0.399     // meshes[21].position.x  
                                      modelCamera.position.y =+0.215        //meshes[21].position.y
                                      modelCamera.position.z =-0.047 //meshes[21].position.z
                                      modelCamera.rotation.z = Math.PI*0.25; // Model mesh roation 
                                      modelCamera.rotation = new BABYLON.Vector3(Math.PI/2 , Math.PI, -Math.PI/2 -0.02); // Get the model rotation for the position control in the function 
                                      var angle2 = 0;
                                      scene.registerBeforeRender(function(){
                                      modelCamera.rotation.y = angle2;
                                      angle2 +=0.01;
                                      });     
                                      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>                                   
                                    
                                    });
                                     // Testing added the acoustic devices 
                                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(Acousticlist[0])+".gltf",scene, function (meshes, particleSystems, skeletons) {
                                    //Get the actuator driver list function to compare the housing size and functional capability under the form factors 
                                     var modelAcoustic = meshes[0]; // Get the acoustic meshes     
                                     modelAcoustic.position.x =+0.388            // meshes[21].position.x  
                                     modelAcoustic.position.y =+0.23         //meshes[21].position.y
                                     modelAcoustic.position.z =-0.024 //meshes[21].position.z
                                     modelAcoutic.rotation.z = Math.PI*0.25; //Model mesh roation 
                                     modelAcoustic.rotation = new BABYLON.Vector3(Math.PI, Math.PI*0.25, Math.PI); //Model rotational function  
                                                                                     

                                   }); 
                                   /*
                                    if(r != 0 ){
                                    for(q = 1; q <=r ;q++){
                                      meshes[q].position.y =+ 0.01;
                                      console.log(String(scene.transformNodes[r].name)); 
                                      console.log(String(r)); // Get the amount the mesh part
                                    }
                                 }
                                 */ 
                                 } 
                                                  
                               }   
                               //Sensor list function classification 
                               if(String(scene.transformNodes[r].name.split(" ")[t]) == PartslistAssem[0]){
                                  //Sensor classification function 
                                  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                  //Calculate the likely area that suitable of the sensor board  
                                  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                       //Work space on loading the model into the position 
                                  BABYLON.SceneLoader.ImportMesh("","static/" ,String(Sensorslist[0])+".gltf",scene, function (meshes, particleSystems, skeletons) {
                                                                                                                       
                               

                                  }); // load the model by using the loop of the model detel automaticly compate to the shape that likely able to connect with the part to assembly together
                                  

                               }
                               //Actuators list function classification 
                               if(String(scene.transformNodes[r].name.split(" ")[t]) == PartslistAssem[2])
                               {
                                 //Actuators classification function 
                                 //Calculate the likely area that suitable of the Actuators
                                 BABYLON.SceneLoader.ImportMesh("","static/" ,String(Actuatorslist[0])+".gltf",scene, function (meshes, particleSystems, skeletons) {
                                   


                                 }); // load the model by using the loop of the model detel automaticly compate to the shape that likely able to connect with the part to assembly together

                               }
                               //Actuators driver list funciton classification 
                               if(String(scene.transformNodes[r].name.split(" ")[t]) == PartslistAssem[3]){
                                //Actuators driver classification function 
                                //Calculate the likely area that suitable of the Actuators driver
                                BABYLON.SceneLoader.ImportMesh("","static/" ,String(ActuatorsDriverlist[0])+".gltf",scene, function (meshes, particleSystems, skeletons) {
                                  //Get the actuator driver list function to compare the housing size and functional capability under the form factors 


                                }); // load the model by using the loop of the model detel automaticly compate to the shape that likely able to connect with the part to assembly together
                               }
                              //Battery list function classication   
                               if(String(scene.transformNodes[r].name.split(" ")[t]) == PartslistAssem[4]){
                                //Battery classification function           
                                //Caclulate the likely area of the Battery
                                  
                               } 
                                //Camera list function classification  
                               if(String(scene.transformNodes[r].name.split(" ")[t]) == PartslistAssem[5]){
                                 //Camera classification function                                                                       
                                 //Calculate the likely area of the Camera
                                 BABYLON.SceneLoader.ImportMesh("","static/" ,String(Opticsensorlist[0])+".gltf",scene, function (meshes, particleSystems, skeletons) {
                                  //Get the actuator driver list function to compare the housing size and functional capability under the form factors 


                                });

                               }
                                //GPS list function classification
                               if(String(scene.transformNodes[r].name.split(" ")[t] == PartslistAssem[6])){ 
                                // GPS classification function
                                //Calculate the likely area of the GPS
                                BABYLON.SceneLoader.ImportMesh("","static/" ,String(Navigationsensorlist[0])+".gltf",scene, function (meshes, particleSystems, skeletons) {
                                  //Get the actuator driver list function to compare the housing size and functional capability under the form factors 


                                });

                               }
                               if(String(scene.transformNodes[r].name.split(" ")[t] == PartslistAssem[7])){

                                  // Acoustic list application of the sound active and passive 
                                  /*
                                 BABYLON.SceneLoader.ImportMesh("","static/" ,String(Acousticlist[0])+".gltf",scene, function (meshes, particleSystems, skeletons) {
                                  //Get the actuator driver list function to compare the housing size and functional capability under the form factors 


                                });
                                */

                               }
                              

                                       
                  }             
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>                             
         
                                                


                     }); // Loading the meshes file from the model and control the meshes motion control 
                        // Mesh picker image and the color of the mesh display 
                    var selected = null;
                     scene.onPointerObservable.add(function(evt){
                     if(selected) {
                              //selected.material.diffuseColor = BABYLON.Color3.Gray();
                              selected = null;
                     }
                     if(evt.pickInfo.hit && evt.pickInfo.pickedMesh && evt.event.button === 0){
                          selected = evt.pickInfo.pickedMesh;
                          evt.pickInfo.pickedMesh.material.diffuseColor = BABYLON.Color3.Green();
                     }
                    
                     }, BABYLON.PointerEventTypes.POINTERUP);
                     scene.clearColor = new BABYLON.Color3(.6,.6,.6);
                     //var groundplane = BABYLON.Mesh.CreateGroundFromHeightMap("static/textures/whiteplane.png", 100, 100, 100, 0, 10, scene, false);
	                  //groundplane.material = new BABYLON.GridMaterial("groundMaterial", scene);
	

                     return scene;
                       
                     }; // Part of the scene created  
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 
                    var scene = createScene(); // Calling the create scene function 
                    engine.runRenderLoop(function () {
                    scene.render(); 
             });
             
     });   
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Classifications function of the MCU part and the motor driver part 
// Get the servo position of the full model then 
function Partclassfication(mcusname,Servopos,motordriver,voltage,current,torque,comprotocol){
// Caclulating the part size from the pcb position and getting the route data from the pcb of the premate the texture will be running on the 
var listmotordriver = ['DCgearmotor','BLDCgearmotor','Steppergearmotor','DCplanetarygear','Steppermotorwithplanetary gear','BLDCwithplanetarygearmotor','LinearDCmotor','LinearBLDCmotor','Linearsteppermotor']; // List of the motor driver 
var q; // Looping the motor driver to check the driver type selection function on the board 
var s; // List the servo part positioning 
// Looping the motor driver search 
for(q=0; q < listmotordriver.length;q++){ 
  //Motor driver  selection function of the computer chip calculating the pinsmap function and the size of the motor driver 
  // Using the electrical data and mesh texture calculating the density of the routing pcb from the area of the routing and position x,y 
  if(motordriver == listmotordriver[q]) // Get the position of the motor driver  
  {
     //Running the loop to check the model  
     for(s= 0;s < Servopos.length;s++){  
      
      if(Servopos[s] == 'Servo'){    //Detecting the board of the pcv on the driver 
                     
                  var listservopos; // Get the lists of the position of the servo motor part board pcb 
                  var listmcusearch; // Get the list of the mcus on the board 
                  var listofmotordriver; //Get the list of the motor driver function 
                  //Classifications of the mesh pcb part of the servo motor 
                  // Input the servo data from the pcb data transformnode mesh part from the root
                  BABYLON.SceneLoader.ImportMesh("","static/",String(listservopos[s])+".gltf"),scene,function(meshes, particleSystems, skeletons){
                  //Get the mesh classification function of the pcb part of the servo motor 
                  var modelServopcb = meshes[0]  // Get the mesh positioing 
                   
                  // Classify mesh and get the position of the motor driver and mcu that control the boad onboard computer
                  BABYLON.SceneLoader.ImportMesh("","static/" ,String(listmotordriver[q]+".gltf"),scene,function(meshes, particleSystems, skeletons){
                  var modelActuatorsdriver = meshes[0]; // Get the mesh of the parts 
                  //The function of the mesh port positioning transfer 
                  // Get the current position of the actuator driver board with the original shape  
                  console.log(modelActuatorsdriver.position.x); 
                  console.log(modelActuatorsdriver.position.y); 
                  console.log(modelActuatorsdriver.position.z); 
                  //Get the translation algorithm for calculate the positioning on the mesh model
                  // Get the  servo pcb position
                  // Get the mesh position of the servo pcb  
                  console.log(modelServopcb.position.x); 
                  console.log(modelServopcb.position.y);
                  console.log(modelServopcb.position.z);                  
      //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
            // Console log of the Actuators positioning of the servo motor and detect the pcb 
                  //find the name of the microcontroller and motor driver chip 
               
              
     }); //The Scene loeader function for the model loader of the actuators motors driver scehematic and the circuit onboard 
     
    }
          
  }
}
}
else{
     alert("Not found the servo parts in the model can't generate the servo actuators driver"); // Alert the servo motor driver function 
}

}

}
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//Part assembly after classificaitons 
function Partassemblycircuit(chipnameclass,angleschip,pinsmode){   
// Get the angle of the chip and the pins mode to compate to the pins connection of the old chip and position of the chip after that calibrate the size of the chip 
    



}
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  var f2 = gui.addFolder('Create scene');
     var f3 = f2.add(scene,'add').name('Scene add'); //  add the object into the scene for testing function of the phusical analysis
     var v4 = f2.add(Plane,'add').name('Terrain scene'); // add the function of the terrain 
     
  var f5 = gui.addFolder('Physic analysis');    
     var f11 = f5.addFolder('Control parameters'); // Control the physical environment parameter 
           var f51 = f11.addFolder('Testing environment terrain parameters');
                  // Terrain parameter containing the roughness and the friction data from the user adjustment
                                                 //Select the biome of the environment for testing the robot or product in the different environment from different specific data function 
                  var f52  = f51.add(terrainplane,'message',['Plane-Geometric','Catbot demo','Catbotboneslf','Dronesmallcontruction','Space area','Maze','desert','Forest','Sea']).name("Terrain-type");     
                  f52.onChange(function(value){
                       var Planeterrain = TerrainA.style.message = value; // Message from the row selection function for select the terrain environment function 
                       console.log(String(Planeterrain)); // Display the output from differrent bio sphia of the world to see the environment that robot can go or working in different area according to the data specificaiton 
                       var Terrainspliter = String(Planeterrain); 
                       var datasplitter = Terrainspliter.split("-"); // Get the split value
                       console.log(datasplitter); 
                       comvis.push(["Terrain-type",String(Planeterrain)]); // Get the plane terrain data 
         //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                   // Choosing the specific terrain function for each terrain from the selector 

                
                     console.log("Start the Rough terrain"); // Rough terrain function for the model testing simulation environment 
                    
                     var canvas = document.getElementById("renderCanvas"); // Get the canvas element
                     var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
                     var createScene = function(){
                     var scene = new BABYLON.Scene(engine); // Create scene 
                     var gravityVector = new BABYLON.Vector3(0,-9.81, 0);
                     var physicsPlugin = new BABYLON.CannonJSPlugin();
                      // Enable gravity into the scene 
                     scene.enablePhysics(gravityVector, physicsPlugin); // Enable the physics engine 
                     
                     //scene.useRightHandedSystem = true;  //user Right Hand System
                     camera = new BABYLON.ArcRotateCamera("camera", 4.712, 1.571, 2, BABYLON.Vector3.Zero(), scene);
                     camera.attachControl(scene.getEngine().getRenderingCanvas());
                     camera.minZ = 0.1;
                     camera.maxZ = 1000;
                     camera.lowerRadiusLimit = 0.1;
                     camera.upperRadiusLimit = 5;
                     camera.wheelPrecision = 100;
                     camera.attachControl(canvas, true);
                    
                     // Add the light to the scene 
                     var light1 = new BABYLON.HemisphericLight("light1",new BABYLON.Vector3(1,1,0), scene); // Adding the light into the scene 
                     var light2 = new BABYLON.PointLight("light2",new BABYLON.Vector3(0,1,1), scene); // Create the point light into the scene positioning  
                     // Create the schere to testing the mesh in the scene  
                     //var sphere = BABYLON.MeshBuilder.CreateSphere("sphere",{diameter:2},scene); // Get the sphere 
                     
                     BABYLON.SceneLoader.LoadAssetContainer("static/", String(Planeterrain)+".gltf", scene, function (container) {
                         var meshes = container.meshes;
                         var materials = container.materials;
                         //var skeleton = skeletons[0];
                         var mesh = meshes[0];
                         console.log(meshes[0]);
                         //Container add all scene 
                         container.addAllToScene();
                     });
                     //var strData = JSON.stringify(transformNodes);
                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(Planeterrain)+".gltf", scene, function (meshes, particleSystems, skeletons) {
                        var model = meshes[0];  // Get the model Mesh part 
                        //console.log(String(model)); //Get the model data 
                        console.log(scene.rootNodes); // Get the rootNodes successfully to get the bone and mesh list 
                        console.log(scene.rootNodes.length); // Get the root nodes length from the function from the file
                        model.rotation.y = Math.PI*0.25; // Model mesh roation 
                        meshes.rotation = new BABYLON.Vector3(Math.PI/2, Math.PI/2, Math.PI/2);
                        
                        var t = 0;
                        var i; 
                        for(i = 0; i <= scene.rootNodes.length; i++){ 

                              console.log(scene.rootNodes[i].name);
                              if(String(scene.rootNodes[i].name) == '__root__')
                              {
                                  console.log("Found to root");
                                  console.log(scene.rootNodes[i]); 
                                  console.log(scene.transformNodes); // Get the node of the mesh list name to make the motion control part rotation manipulaiton 
                                  console.log(scene.addReflectionProbe);
                               
                              } 
                              for(r = 0 ; r < scene.transformNodes.length; r ++)
                                  {  
                                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                     // Reading the element of the GLTF Mesh model file for the motion control and analysis
                                       if(String(scene.transformNodes[r].name) == 'Camera'){ 
                                          console.log("Camera for perspective on the mesh model"); // Get the perspective mesh model 
                                          console.log("Get the camera scene"+scene.cameras);  // Get the camera data int the scene 
                                       }
                                        // Light for the environment optical control 
                                       if(String(scene.transformNodes[r].name) == 'Light'){
                                           console.log("Light for the environment optical element");
                                       }
                                       //console.log(scene.transformNodes[r].name);
                                       if(String(scene.transformNodes[r].name).split(".").length != 2 && String(scene.transformNodes[r].name) != 'Light' ){
                                          
                                           if(String(scene.transformNodes[r].name) != 'Camera' && String(scene.transformNodes[r].name) != 'Bone'){ 
                                              console.log("Mesh part name data" + "\t" + scene.transformNodes[r].name);  // Get the part name of the model 
                                             
                                             }
                                       }
                                       if(String(scene.transformNodes[r].name).split(".").length == 2){
                                          var s;  // Screate the variable for list of the part in the gltf file
                                          for(s = 0; s < String(scene.transformNodes[r].name).split(".").length ;s++)
                                          {
                                             if(String(scene.transformNodes[r].name).split(".")[s] == 'Bone'){
                                                 console.log(String(scene.transformNodes[r].name).split(".")[0] + "\t" +"bone Parts number" + String(scene.transformNodes[r].name).split(".")[1]); 
                                                 
                                                 //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                                          //Get the mesh of the part name to running on the Application 
                                                  //NLP parts analysis part and positioning 


                                                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                             }
                                          }
                                     }
                                    
                                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>                             
                                 }
                            
                                  var w; 
                                  for(w = 0 ; w < scene.meshes.length ;w++){
                                         console.log(String(scene.meshes[w])); 
                                         console.log(scene.meshes[w]['position']);
                                         console.log(typeof(scene.meshes[w]['position'])); // Get the type of variable  
                                         var f87 = f27.add(kinematicsalgo,'kinematicsjoint',scene.meshes[w]['position']).name(scene.meshes[w]['name']); //Get the kinematics listed control 
                                              f87.onChange(function(value){
                                                  var KineData = kinematics.style.kinematicsjoint = value; //Get the kinematics joint list parts 
                                                  console.log(String(KineData));// Get the value of the positioning data  
                                                  //Get the pisition of the model mesh for the body mesh name position 
                                                       
                                             
                                         });
                                   } 
                                   console.log(String(scene.materials));  // Get the materials from the mesh in the scene function 
                                   var q;
                                   for(q = 0; q <= scene.materials.length;q++){
                                   var f57 = f56.add(materialcontrol,'matprop',scene.materials[q]).name(scene.materials[q]['id']); //Density of the materials adjust from the daw input 
                                   f57.onChange(function(value){
                                   var Densitydata = densitys.style.matprop = value; 
                                   console.log(String(Densitydata)); // Density of materials data
                                   comvis.push(["Density-data",String(Densitydata)]); // Get the density data for the materials   
                                   //Get the material density read 
                                      
                                 });
                              }   
                       }  
                       
                     
                     }); // Loading the meshes file from the model and control the meshes motion control 
                     
                     return scene;
                       
                     }; // Part of the scene created  
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 
                    var scene = createScene(); // Calling the create scene function 
                    engine.runRenderLoop(function () {
                    scene.render(); 
                    });
                  
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                      // Add event listener  
                    //window.addEventListener("resize", function () {
                    //engine.resize();
                   //});
                 
                  
                });
           //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                           //Environment selection 



          //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
           var f56 = f11.addFolder("Materials parameters");  // Setting the materials parameter of model 
                    // Add the Materials parameter into the system 
                    /*
                    var f57 = f56.add(materialcontrol,'matprop',['Solid','Rubbery','Liquid','Fluid','Gas']).name("Materials prop"); //Density of the materials adjust from the daw input 
                    f57.onChange(function(value){
                       var Densitydata = densitys.style.matprop = value; 
                       console.log(String(Densitydata)); // Density of materials data
                       comvis.push(["Density-data",String(Densitydata)]); // Get the density data for the materials   
                    });
                    */
                    var f59 = f56.add(materialcontrol,'Opticprop',0,25000).name("Optical property"); //  Control the shining parameters of the skin 
                    f59.onChange(function(value){
                         var shineskindata = Lightmat.style.Opticprop = value;  // Get the shining skin data of the materials to adjust on the materials design 
                         console.log(String(shineskindata)); // Get the data of the materials skin function 
                         comvis.push(["Materials-opacity",String(shineskindata)]); // Get the materials opacity 
                    });
                    
                    var f60 = f56.add(materialcontrol,'Densitys',0,12).name("Density"); //Materials property function of the  
                    f60.onChange(function(value){
                         var Densitysdata = Densitymat.style.Densitys = value; // Density data from the json file  function 
                         console.log(String(Densitysdata)); // Display the density data function 
                         comvis.push(["Materials-Density-data",Densitysdata]); // Upload the materials data into the the devices operation   
                    });
                    
                  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                     // Materials color sdjustment function  
                    var f61 = f56.addColor(materialcontrol,'color0'); 
                    f61.onChange(function(value){
                         var color0data =  color0mat.style.color0 = value; //Get the color0 data value 
                         console.log(String(color0data)); // Color 0 data out put into the console and control the materials color mixer function 
                         comvis.push(["Materials-color0",String(color0data)]);      
                   });
                    var f62 = f56.addColor(materialcontrol,'color1');    // Get the color data to mixing on the robot optical materials 
                    f62.onChange(function(value){
                        var color1data = color1mat.style.color1 = value; // Get the color1 data value 
                        console.log(String(color1data)); // Get the color 1 data function 
                        comvis.push(["Materials-color1",String(color1data)]);   // Get the data to mixing on the robot optical materials 

                    });
                    
                  //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

  var f6 = gui.addFolder('Specifications');  // Specification of the product    
     var f12 = f6.addFolder('Materials specifications'); // Materials spefication input  
           // The Specificaition contain 
        // 0) Select the materials using in the specification 
        // 1) Materials name and physics properties 
        // 2) Materials optical characteristic 
      var f46 = f12.add(text, 'message',['Plastic','Metal','Rubber','Composite']).name("Materials"); //list of the materials data for the products development 
            console.log(String(this.message = text)); //Function of the 
            f46.onChange(function(value){ 
               var materials = dit.style.message = value; // Get the value  get hte message 
               console.log(String(materials)); // Console function to dsplay materials data into the console in the web 
               var mat = String(materials); 
               var lenghtmat = mat.length; 
               console.log(lenghtmat); // Get the materials lenght function 
               comvis.push(["Materials-type",materials]); // Get the material type for the data processing on the device to calculate the possibility and surviability   
            });
     var f13 = f6.addFolder('PCB specification');  // Circuit specification function
              // PCB Layers selector function  
           var f63 = f13.add(pcbop,'layers',['1','2','4','6']).name('PCB-layers') // Select the pcb layer 
           f63.onChange(function(value){
                var layers = pcblayer.style.pcbop = value; // PCB layers configuretion data from the database and automated pcb genergator software 
                console.log(String(layers)); // Get the pcb layers data extraction from the data base to display after generated pcb  
                comvis.push(["PCB-Layers",String(layers)]); //Get the pcb layer for the data computability on owning the part manufacturing by itself collect all components onboard          
           });      
           // PCB color selection function 
           var f64 = f13.add(pcbop,'colors',['Red','Green','Yellow','Blue','White','Black']).name('PCB-Color')  // Select the pcb color on the board 
           f64.onChange(function(value){
               var pcbcolordata = pcbcolor.style.colors = value;  // Get the value of the solocr slected function 
               var f65 = f13.addColor(pcbop,String(pcbcolordata)); // pcb color example
               f65.onChange(function(value){
                   var Samplecolor = displaycolor.style.String(pcbcolordata) = value; 
                   console.log(String(Samplecolor)); // Sample of the color
                   comvis.push(["PCB-colors",String(Samplecolor)]); //Get the details color of the pcb to send the part manufacturing when the devices or robot broken  
               });
           });
            //PCB materials  PCB data from the 
           var f66 = f13.add(pcbop,'materials',['FR4-Standard Tg 130-140C','FR1-Standard Tg 105-130C','FR3-Standard Tg 105C']).name('PCB-materials'); 
           f66.onChange(function(value){
               var pcbmatdata = pcbmaterials.style.materials = value; 
               console.log(String(pcbmatdata)); // PCB matdata for 
               comvis.push(["PCB-materials",String(pcbmatdata)]); // Get the pcb baterials data in the function to know the surviability and over all possibility on the product calculation function 
               
            });
            
          
     var  f17 = f6.addFolder('Computer onboard specification'); // Select the computer onboard specification function  Get the list data from the database 
             var f67 = f17.add(onboadComputing,'sbcspect',['raspberryPi3B','RaspberryPiZeroW','Beagleboneblack','BeagleBoneblue','SnapDragon','Jetsonnano','JetsonXavierNX']).name("SBCspect")
             f67.onChange(function(value){
                 var SBCdata = SBCSpec.style.sbcspect = value; // Get the value of the sbc specification data 
                 console.log(SBCdata); // Display the sbc specification for onboard edge computing on the robotics 
                 comvis.push(["SBC-computer",String(SBCdata)]); // Get the data of the Single board computer for the computing capability selection function  
                 console.log(String(SBCdata)+"\t"+"model part for single board computer you selected");
                 alert("Some complex circuit board may take a few minutes if you can't move it that mean it's constructing model parts");
                 console.log("Loading the model ...."); // Rough terrain function for the model testing simulation environment 
                 BABYLON.SceneLoader.ImportMesh("","static/" ,String(SBCdata)+".glb", scene, function (meshes, particleSystems, skeletons) {
                            var modelSbc  = meshes[0]; // Get the full model part to put into the position where the part should assembly 
                 //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                      //List of the position where the part should live 
                                       // Compare and calibrate the position of the real computer holder part with the mannual calibrated numerical 
                            modelSbc.position.x =+0.455           // meshes[21].position.x  
                            modelSbc.position.y =+0.26        //meshes[21].position.y
                            modelSbc.position.z =+0.135  //meshes[21].position.z
                            modelSbc.rotation.z = Math.PI*0.25; // Model mesh roation 
                            modelSbc.rotation = new BABYLON.Vector3(-Math.PI/2 - 0.01, Math.PI-0.7, Math.PI/2+0.05); // Get the model rotation for the position control in the function 
                                      
               //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>                                   
                                    
                      });
                      return scene;
                 
                });
                     
   
     var  f18 = f6.addFolder('Transducer and sensors specification');  // Select the category of the sensors that will using in the environment function 
              // add the function of the Transducer sensor type selection function 
              var f67 = f18.add(transducer,'Sensorstype',['Physics base property','Chemical base property','Biological base propery']).name("Sensors-type"); // Get the sensor type for transducer selection schematic automatically 
              f67.onChange(function(value){
                   var Transducerselectdata = TransducerSpec.style.Sensorstype = value; //Sensors Specification function 
                   console.log(String(Transducerselectdata)); //Sensor tranducer selection function for select the Transducer for sensor 
                   comvis.push(["Transducer-data",String(Transducerselectdata)]); //Transducerdata selection for the board selection on the environment and functional capability                    
                   //Query physics base data for the sensors type function from the database or JSON base file  
                   if(String(Transducerselectdata) == "Physics base property"){
                        console.log("Query data from the database into the Physics base property"); //Query the physics base data 
                            
                   } // Query data from the database into the Physics base property 
                   //Query Chemicalbase data for the sensor from the database 
                   if(String(Transducerselectdata) == "Chemical base property")   
                   {
                    console.log("Query data from the database into the Chemical base property")  //Query the Chemical base data 
                    
                   }
                   //Query Biological data for the sensor from the databse 
                   if(String(Transducerselectdata) == "biological base property")
                   {
                      console.log("Query data from the database into the Biological base property"); //Query the Biological base data
                      
                   }
                   


              });

     var  f19 = f6.addFolder('Microcontroller specification'); // Micro controller specification select to generate the onboard controller 
          var f68  = f19.add(microControl,'MCUname',['Neucleo-32','Neucleo-64','Neucleo-144','Generic STM32F0 Series','Generic STM32F1 Series','Generic STM32F4 Series']).name("STM32-MCU"); // 
          f68.onChange(function(value){
               var mculistdata = mcuseries.style.microControl = value; // MCU list series value out 
               console.log(String(mculistdata)); // List mcu data from the list log data
               comvis.push(["Microcontroller-data",String(mculistdata)]);  //Micro controller data function 
          //Neucleo 32 data for generate the schematic modification and pre code in visual programming code 
          if(String(mculistdata) == 'Neucleo-32'){
             console.log("Selected Neucleo-32 series");
             var f71 = f19.add(microControl,'Neucleo32list',['Nucleo-F031K6','Nucleo-L031K6','Nucleo-L412KB','Nucleo-F303K8','Nucleo-G431KB']).name("Neucleo-32"); 
             f71.onChange(function(value){
                    var Neucleo32data = neucleo32list.style.Neucleo32list = value; //Show the neucleo 
                    console.log(String(Neucleo32data)); // Get the Neucleo32 data  
                    alert(String(Neucleo32data));
                    if(Neucleo32data =="Nucleo-F031K6"){  // Reading the micro controller data selected from the list 
                        var mcuRequest = new XMLHttpRequest(); //
                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                        mcuRequest.onload = function() {
                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                        console.log("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32F031K6[0] +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32F031K6); // Microcontroller spec 
                        
                        alert(String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32F031K6 +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32F031K6)); //Alert the spec 
                        comvis.push([String(Neucleo32data),String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32F031K6 +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32F031K6)]); 
                        if(mcuData[1].mcufamily.Specifications.STM32F031K6[6].split(" ")[1] == 'Active'){
                          
                           alert(String("Part:" + mcuData[1].mcufamily.Specifications.STM32F031K6[6].split(" ")[1])); // Get the status alert on the function 
                           // Working on the packages classification and model selection for display the pins and setting on each function leg  
                           // The prepackages data that working with the driver must display in the same way with circuit onboard 
                           // Select the type of circuit onboard to auto generated  
                           //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                        }
                        else{

                           alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                        };
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                        //Classifymcudata(mcuData); // Get the request from the mcu 
            
                        
                        
      
                     }
                    if(Neucleo32data == "Nucleo-L031K6")
                    {
                     var mcuRequest = new XMLHttpRequest(); //
                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                        mcuRequest.onload = function() {
                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                        console.log("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32L031K6[0] +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32L031K6); // Microcontroller spec 
                        
                        alert(String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32L031K6 +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32L031K6)); //Alert the spec 
                        comvis.push([String(Neucleo32data),String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32L031K6 +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32L031K6)]); 
                        if(mcuData[1].mcufamily.Specifications.STM32L031K6[6].split(" ")[1] == 'Active'){
                          
                           alert(String("Part:" + mcuData[1].mcufamily.Specifications.STM32L031K6[6].split(" ")[1])); // Get the status alert on the function 
                           // Working on the packages classification and model selection for display the pins and setting on each function leg  
                           // The prepackages data that working with the driver must display in the same way with circuit onboard 
                           // Select the type of circuit onboard to auto generated  
                           //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                        }
                        else{

                           alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                        };
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                        //Classifymcudata(mcuData); // Get the request from the mcu 
            
                     }
                    if(Neucleo32data == "Nucleo-L412KB")
                    { 
                     var mcuRequest = new XMLHttpRequest(); //
                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                        mcuRequest.onload = function() {
                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                        console.log("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32L412KB[0] +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32L412KB); // Microcontroller spec 
                        
                        alert(String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32L412KB +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32F412KB)); //Alert the spec 
                        comvis.push([String(Neucleo32data),String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32L412KB +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32L412KB)]); 
                        if(mcuData[1].mcufamily.Specifications.STM32F031K6[6].split(" ")[1] == 'Active'){
                          
                           alert(String("Part:" + mcuData[1].mcufamily.Specifications.STM32L412KB[6].split(" ")[1])); // Get the status alert on the function 
                           // Working on the packages classification and model selection for display the pins and setting on each function leg  
                           // The prepackages data that working with the driver must display in the same way with circuit onboard 
                           // Select the type of circuit onboard to auto generated  
                           //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                        }
                        else{

                           alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                        };
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                        //Classifymcudata(mcuData); // Get the request from the mcu 
            
                    }
                    if(Neucleo32data == "Nucleo-F303K8")
                    { 
                     var mcuRequest = new XMLHttpRequest(); //
                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                        mcuRequest.onload = function() {
                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                        console.log("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32F303K8[0] +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32F303K8); // Microcontroller spec 
                        
                        alert(String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32F303K8 +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32F303K8)); //Alert the spec 
                        comvis.push([String(Neucleo32data),String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32F303K8 +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32F303K8)]); 
                        if(mcuData[1].mcufamily.Specifications.STM32F031K6[6].split(" ")[1] == 'Active'){
                          
                           alert(String("Part:" + mcuData[1].mcufamily.Specifications.STM32F303K8[6].split(" ")[1])); // Get the status alert on the function 
                           // Working on the packages classification and model selection for display the pins and setting on each function leg  
                           // The prepackages data that working with the driver must display in the same way with circuit onboard 
                           // Select the type of circuit onboard to auto generated  
                           //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                        }
                        else{

                           alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                        };
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                        //Classifymcudata(mcuData); // Get the request from the mcu 
                 
                    }
                    if(Neucleo32data == "Nucleo-G431KB")
                    { 
                     var mcuRequest = new XMLHttpRequest(); //
                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                        mcuRequest.onload = function() {
                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                        console.log("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32G431KB[0] +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32G431KB); // Microcontroller spec 
                        
                        alert(String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32G431KB +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32G431KB)); //Alert the spec 
                        comvis.push([String(Neucleo32data),String("Board:"+ mcuData[1].Boardseries + "," +"Packages:" +"\t" + mcuData[1].mcufamily.Specifications.STM32G431KB +","+"mcus Spec:"+"\t" + mcuData[1].mcufamily.descriptionsspec.STM32G431KB)]); 
                        if(mcuData[1].mcufamily.Specifications.STM32G431KB[6].split(" ")[1] == 'Active'){
                          
                           alert(String("Part:" + mcuData[1].mcufamily.Specifications.STM32G431KB[6].split(" ")[1])); // Get the status alert on the function 
                           // Working on the packages classification and model selection for display the pins and setting on each function leg  
                           // The prepackages data that working with the driver must display in the same way with circuit onboard 
                           // Select the type of circuit onboard to auto generated  
                           //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                        }
                        else{

                           alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                        }

                        };
                        mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
                        //Classifymcudata(mcuData); // Get the request from the mcu 
            
                    }

             });

          }
          //Neucleo 64 data for generate the schematic modification and pre code in visual programming code  
          if(String(mculistdata) == 'Neucleo-64'){
            console.log("Selected Neucleo-64 series"); //Display the selected option 
            var f70 = f19.add(microControl,'Neucleo64list',['Neucleo-F030R8','Neucleo-F072RB','Neucleo-F091RC','Neucleo-F103RB','Neucleo-F103RB','Neucleo-F303R8','Neucleo-F303RE','Neucleo-F401RE','Neucleo-F411RE','Neucleo-F446RE','Neucleo-G071RB','Neucleo-G431RB','Neucleo-G474RE','Neucleo-L053R8','Neucleo-L073RZ','Neucleo-L152RE','Neucleo-L433RC-P','Neucleo-L452RE','Neucleo-L452RE-P','Neucleo-L476RG','P-Neucleo WB55RG']).name("Neucleo-64"); // Show the list data of the neucleo 64 
            var Neucleo64s = ['Neucleo-F030R8','Neucleo-F072RB','Neucleo-F091RC','Neucleo-F103RB','Neucleo-F103RB','Neucleo-F303R8','Neucleo-F303RE','Neucleo-F401RE','Neucleo-F411RE','Neucleo-F446RE','Neucleo-G071RB','Neucleo-G431RB','Neucleo-G474RE','Neucleo-L053R8','Neucleo-L073RZ','Neucleo-L152RE','Neucleo-L433RC-P','Neucleo-L452RE','Neucleo-L452RE-P','Neucleo-L476RG','P-Neucleo WB55RG']; // Show the list data of the neucleo 64 
            
            f70.onChange(function(value){
                   var Neucleo64data  = neucleo64list.style.Neucleo64list = value; // Show the Neucleo 64 list data 
                   console.log(String(Neucleo64data)); // Get the Neucleo64 data                    
            if(Neucleo64data == "Neucleo-F030R8"){ 
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board"+","+mcuData[0].Boardseries + ","+"Packages"+mcuData[0].mcufamily.Specifications.STM32F030R8 + ":"+"mcus Spec"+","+ mcuData[0].mcufamily.descriptionsspec.STM32F030R8); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F030R8 + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F030R8)); //Alert the spec  
               comvis.push(String(Neucle64)+","+"Board"+","+mcuData[0].Boardseries + ","+"Packages"+mcuData[0].mcufamily.Specifications.STM32F030R8 + ":"+"mcus Spec"+","+ mcuData[0].mcufamily.descriptionsspec.STM32F030R8); 
               console.log(mcuData[0].mcufamily.Specifications.STM32F030R8.length); // Finding the lenght of the list package 
               if(mcuData[0].mcufamily.Specifications.STM32F030R8[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F030R8[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 

                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github        
                
            }   
            if(Neucleo64data == "Neucleo-F072RB")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F072RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F072RB); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F072RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F072RB)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F072RB +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F072RB)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F072RB[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F072RB[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github          
           }
           if(Neucleo64data == "Neucleo-F091RC")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F091RC + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F091RC); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F091RC + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F091RC)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F091RC +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F091RC)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F091RC[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F091RC[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github             
           }
           if(Neucleo64data == "Neucleo-F103RB")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F103RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F103RB); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F103RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F103RB)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F103RB +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F103RB)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F103RB[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F103RB[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github     
           }
           if(Neucleo64data == "Neucleo-F303R8")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board"+","+mcuData[0].Boardseries + ","+"Packages"+mcuData[0].mcufamily.Specifications.STM32F303R8 + ":"+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F303R8); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F303R8 + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F303R8)); //Alert the spec  
               comvis.push("Board"+","+mcuData[0].Boardseries + ","+"Packages"+mcuData[0].mcufamily.Specifications.STM32F030R8 + ":"+"mcus Spec"+","+ mcuData[0].mcufamily.descriptionsspec.STM32F030R8); 
               if(mcuData[0].mcufamily.Specifications.STM32F303R8[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F303R8[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github  
           }
           if(Neucleo64data == "Neucleo-F303RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F303RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F303RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F303RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F303RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F303RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F303RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F303R8[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F303RE[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
           }
           if(Neucleo64data == "Neucleo-F401RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F401RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F401RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F401RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F401RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F401RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F401RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F401RE[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F401RE[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github         
           }
           if(Neucleo64data == "Neucleo-F411RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F411RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F411RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F411RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F411RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F411RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F411RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F411RE[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F411RE[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github  
           }
           if(Neucleo64data == "Neucleo-F446RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F446RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F446RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F446RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F446RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F446RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32F446RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32F446RE[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32F446RE[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github     
           }
           if(Neucleo64data == "Neucleo-G071RB")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G071RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G071RB); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G071RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G071RB)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G071RB +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G071RB)]); 
               if(mcuData[0].mcufamily.Specifications.STM32G071RB[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32G071RB[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
           }
           if(Neucleo64data == "Neucleo-G431RB")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G431RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G431RB); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G431RB + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G431RB)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32F446RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G431RB)]); 
               if(mcuData[0].mcufamily.Specifications.STM32G431RE[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32G431RB[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github           
           }
           if(Neucleo64data == "Neucleo-G474RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G474RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G474RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G474RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G474RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32G474RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32G474RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32G474RE[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32G474RE[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github               
           }
           if(Neucleo64data == "Neucleo-L053R8")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L053R8 + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L053R8); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L053R8 + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L053R8)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L053R8 +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L053R8)]); 
               if(mcuData[0].mcufamily.Specifications.STM32L053R8[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L053R8[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github             
           }
           if(Neucleo64data == "Neucleo-L073RZ")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L073RZ + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L073RZ); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L073RZ + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L073RZ)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L073RZ +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L073RZ)]); 
               if(mcuData[0].mcufamily.Specifications.STM32G073RZ[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L073RZ[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github    
           }
           if(Neucleo64data == "Neucleo-L152RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L152RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L152RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L152RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L152RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L073RZ +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L152RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32G073RZ[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L073RZ[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github       
           }
           if(Neucleo64data == "Neucleo-L433RC-P")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L433RCP + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L433RCP); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L433RCP + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L433RCP)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L433RCP +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L433RCP)]); 
               if(mcuData[0].mcufamily.Specifications.STM32L433RCP[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L433RCP[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github         
           }
           if(Neucleo64data == "Neucleo-L452RE")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452RE); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452RE + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452RE)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452RE +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452RE)]); 
               if(mcuData[0].mcufamily.Specifications.STM32L452RE[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L452RE[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github         
           }
           if(Neucleo64data == "Neucleo-L452RE-P")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452REP + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452REP); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452REP + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452REP)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L452REP +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L452REP)]); 
               if(mcuData[0].mcufamily.Specifications.STM32L452REP[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L452REP[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github       
           }
           if(Neucleo64data == "Neucleo-L476RG")       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L476RG + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L476RG); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L476RG + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L476RG)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.STM32L476RG +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.STM32L476RG)]); 
               if(mcuData[0].mcufamily.Specifications.STM32L476RG[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.STM32L476RG[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github    
           }
           if(Neucleo64data == "P-Neucleo WB55RG")          
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.PNeucleoWB55RG + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.PNeucleoWB55RG); // Microcontroller spec 
               alert(String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.PNeucleoWB55RG + ","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.PNeucleoWB55RG)); //Alert the spec  
               comvis.push([String(Neucleo64data),String("Board:"+ mcuData[0].Boardseries + ","+"Packages:"+mcuData[0].mcufamily.Specifications.PNeucleoWB55RG +","+"mcus Spec:"+"\t" + mcuData[0].mcufamily.descriptionsspec.PNeucleoWB55RG)]); 
               if(mcuData[0].mcufamily.Specifications.PNeucleoWB55RG[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[0].mcufamily.Specifications.PNeucleoWB55RG[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 


                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github          
           }
           
        
        



      });
   }   
          // Neucleo 144 data for the generate the schematic modification and pre code in the visual programming code 
          if(String(mculistdata) == 'Neucleo-144'){
             console.log("Selected Neucleo-144 series"); // Display the selected option 
             var f69 = f19.add(microControl,'Neucleo144list',['Neucleo F207ZG','Neucleo F429ZI','Neucleo F756ZG','Neucleo F767ZI','Neucleo F767ZI','Neucleo H743ZI','Neucleo H743ZI2','Neucleo L496ZG','Neucleo L496ZG-P','Neucleo L4R5ZI','Neucleo L4R5ZI-P']).name("Neucleo-144"); //Get the neucleo 144 series for list and schematic builder 
             var  Neucleo144s = ["Neucleo F207ZG","Neucleo F429ZI","Neucleo F756ZG","Neucleo F767ZI","Neucleo F767ZI","Neucleo H743ZI","Neucleo H743ZI2","Neucleo L496ZG","Neucleo L496ZG-P","Neucleo L4R5ZI","Neucleo L4R5ZI-P"]; 
             f69.onChange(function(value){
                 //Extract the list of the neucleo -144 board
                 var Neucleo144data = neucleo144list.style.Neucleo144list = value; // Get the value of the Neucleo 144 for the pins display and schematic for modify the user circuit board for the robot onboard 
                 console.log(String(Neucleo144data)); // Get the Neucleo144 data
             if(Neucleo144data == "Neucleo F207ZG"){

               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F207ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F207ZG); // Microcontroller spec 
               alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F207ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F207ZG)); //Alert the spec  
               comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F207ZG +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F207ZG)]); 
               if(mcuData[2].mcufamily.Specifications.STM32F207ZG[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32F207ZG[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github 
             }    
             if(Neucleo144data == String(Neucleo144s[1])){

               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F429ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F429ZI); // Microcontroller spec 
               alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F429ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F429ZI)); //Alert the spec  
               comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F429ZI +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F429ZI)]); 
               if(mcuData[2].mcufamily.Specifications.STM32F429ZI[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32F429ZI[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
               }    
               if(Neucleo144data == String(Neucleo144s[2])){

                var mcuRequest = new XMLHttpRequest(); //
                mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                mcuRequest.onload = function() {
                var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F756ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F756ZG); // Microcontroller spec 
                alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F756ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F756ZG)); //Alert the spec  
                comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F756ZG +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F756ZG)]); 
                if(mcuData[2].mcufamily.Specifications.STM32F756ZG[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32F756ZG[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                }
                else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github 
               }
               if(Neucleo144data == String(Neucleo144s[3])){

                 var mcuRequest = new XMLHttpRequest(); //
                 mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                 mcuRequest.onload = function() {
                 var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                 console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI); // Microcontroller spec 
                 alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI)); //Alert the spec  
                 comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI)]); 
                 if(mcuData[2].mcufamily.Specifications.STM32F767ZI[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32F767ZI[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                 }
                 else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github    
               }
               if(Neucleo144data == String(Neucleo144s[4]))       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI); // Microcontroller spec 
               alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI)); //Alert the spec  
               comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32F767ZI +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32F767ZI)]); 
               if(mcuData[2].mcufamily.Specifications.STM32F767ZI[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32F767ZI[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                 }
                 else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
           }
           if(Neucleo144data == String(Neucleo144s[5]))       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI); // Microcontroller spec 
               alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI)); //Alert the spec  
               comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI)]); 
               if(mcuData[2].mcufamily.Specifications.STM32H743ZI[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32H743ZI[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                 }
                 else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github    
           }
           if(Neucleo144data == String(Neucleo144s[6]))       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI2 + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI2); // Microcontroller spec 
               alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI2 + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI2)); //Alert the spec  
               comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32H743ZI2 +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32H743ZI2)]); 
               if(mcuData[2].mcufamily.Specifications.STM32H743ZI2[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32H743ZI2[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                 }
                 else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      
           }
           if(Neucleo144data == String(Neucleo144s[7]))       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZG); // Microcontroller spec 
               alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZG + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZG)); //Alert the spec  
               comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZG +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZG)]); 
               if(mcuData[2].mcufamily.Specifications.STM32L496ZG[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32L496ZG[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                 }
                 else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
           }
           if(Neucleo144data == String(Neucleo144s[8]))       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZGP + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZGP); // Microcontroller spec 
               alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZGP + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZGP)); //Alert the spec  
               comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L496ZGP +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L496ZGP)]); 
               if(mcuData[2].mcufamily.Specifications.STM32L496ZGP[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32L496ZGP[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                 }
                 else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github    
           }
           if(Neucleo144data == String(Neucleo144s[9]))       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZI); // Microcontroller spec 
               alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZI + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZI)); //Alert the spec  
               comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZI +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZI)]); 
               if(mcuData[2].mcufamily.Specifications.STM32L4R5ZI[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32L4R5ZI[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                 }
                 else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github       
           }
           if(Neucleo144data == String(Neucleo144s[10]))       
            {
               
               var mcuRequest = new XMLHttpRequest(); //
               mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
               mcuRequest.onload = function() {
               var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
               console.log("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZIP + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZIP); // Microcontroller spec 
               alert(String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZIP + ","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZIP)); //Alert the spec  
               comvis.push([String(Neucleo144data),String("Board:"+ mcuData[2].Boardseries + ","+"Packages:"+mcuData[2].mcufamily.Specifications.STM32L4R5ZIP +","+"mcus Spec:"+"\t" + mcuData[2].mcufamily.descriptionsspec.STM32L4R5ZIP)]); 
               if(mcuData[2].mcufamily.Specifications.STM32L4R5ZIP[6].split(" ")[1] == 'Active'){
                          
                     alert(String("Part:" + mcuData[2].mcufamily.Specifications.STM32L4R5ZIP[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                 }
                 else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github         
           }
         }); 
            
          }
          if(String(mculistdata) == 'Generic STM32F0 Series'){
                   console.log("Selected GenericSTM32F0 series");
                   var f184 = f19.add(microControl,'GenericF0list',['STM32F030F4']).name("GenericF0"); 
                   f184.onChange(function(value){
                   var GenericF0data = genericstm32F0.style.GenericF0list = value; //Show the neucleo 
                   console.log(String(GenericF0data)); // Get the Neucleo32 data  
                   alert(String(GenericF0data));
                   if(GenericF0data =="STM32F030F4"){  // Reading the micro controller data selected from the list
                                        var mcuRequest = new XMLHttpRequest(); //
                                        mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                                        mcuRequest.onload = function() {
                                        var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                                        console.log("Board:"+ mcuData[3].Boardseries + "," +"Packages:" +"\t" + mcuData[3].mcufamily.Specifications.STM32F030F4[0] +","+"mcus Spec:"+"\t" + mcuData[3].mcufamily.descriptionsspec.STM32F030F4); // Microcontroller spec 
                                        alert(String("Board:"+ mcuData[3].Boardseries + "," +"Packages:" +"\t" + mcuData[3].mcufamily.Specifications.STM32F030F4 +","+"mcus Spec:"+"\t" + mcuData[3].mcufamily.descriptionsspec.STM32F030F4)); //Alert the spec 
                                        comvis.push([String(GenericF0data),String("Board:"+ mcuData[3].Boardseries + "," +"Packages:" +"\t" + mcuData[3].mcufamily.Specifications.STM32F030F4 +","+"mcus Spec:"+"\t" + mcuData[3].mcufamily.descriptionsspec.STM32F030F4)]); 
                                        if(mcuData[3].mcufamily.Specifications.STM32F030F4[6].split(" ")[1] == 'Active'){
                                          alert(String("Part:" + mcuData[3].mcufamily.Specifications.STM32F030F4[6].split(" ")[1])); // Get the status alert on the function 
                                                    

                                  }
                                  else
                                          {
                                                alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                                        }
                   }
                   mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github      

                  }
               //end of GenericSTM32F0 
               });

         }          
         if(String(mculistdata) == 'Generic STM32F1 Series'){
            console.log("Selected Generic STM32F1 Series"); // Display the selected option 
            var f84 = f19.add(microControl,'GenericF1list',["STM32F103C6","STM32F103C8","STM32F103CB","STM32F103C4","STM32F103R4","STM32F103R6","STM32F103R8","STM32F103RC","STM32F103RD","STM32F103RE","STM32F103RF","STM32F103RG","STM32F103T4","STM32F103T6","STM32F103TB","STM32F103V8","STM32F103VB", "STM32F103VC","STM32F103VD","STM32F103VE","STM32F103VF","STM32F103VG","STM32F103ZC","STM32F103ZD","STM32F103ZE","STM32F103ZF","STM32F103ZG","STM32F103ZET6","HYTinySTM32F103TB","MapleSTM32F103CB"]).name("GenericF1");
            var GenericF1s = ["STM32F103C6","STM32F103C8","STM32F103CB","STM32F103C4","STM32F103R4","STM32F103R6","STM32F103R8","STM32F103RC","STM32F103RD","STM32F103RE","STM32F103RF","STM32F103RG","STM32F103T4","STM32F103T6","STM32F103TB","STM32F103V8","STM32F103VB", "STM32F103VC","STM32F103VD","STM32F103VE","STM32F103VF","STM32F103VG","STM32F103ZC","STM32F103ZD","STM32F103ZE","STM32F103ZF","STM32F103ZG","STM32F103ZET6","HYTinySTM32F103TB","MapleSTM32F103CB"]; 
            f84.onChange(function(value){
               var GenericF1data = genericstm32F1.style.GenericF1list = value; // Get the value of the Neucleo 144 for the pins display and schematic for modify the user circuit board for the robot onboard 
               console.log(String(GenericF1data)); //Get the genetic f1 data        
               if(GenericF1data == String(GenericF1s[0])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"Packages:"+mcuData[4].mcufamily.Specifications.STM32F103C6 + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C6); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"Packages:"+mcuData[4].mcufamily.Specifications.STM32F103C6 + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C6)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[3].Boardseries + ","+"Packages:"+mcuData[3].mcufamily.Specifications.STM32F103C6 +","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C6)]); 
                    if(mcuData[4].mcufamily.Specifications.STM32F103C6[6].split(" ")[1] == 'Active'){
                          
                          alert(String("Part:" + mcuData[4].mcufamily.Specifications.STM32F103C6[6].split(" ")[1])); // Get the status alert on the function 
                          // Working on the packages classification and model selection for display the pins and setting on each function leg  
                          // The prepackages data that working with the driver must display in the same way with circuit onboard 
                          // Select the type of circuit onboard to auto generated  
                          //Loading the 3d part mesh design into the web and modify with the new part added into the system 
                 }
                 else{

                          alert(String("Part:" + "In active")); // The part inactive for the part that stoped working 
                }
        
               };
               mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                     
               }
               if(GenericF1data == String(GenericF1s[1])){
                  var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C8); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C8)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C8)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          



               }
               if(GenericF1data == String(GenericF1s[2])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103CB); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103CB)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103CB)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          



               }
               if(GenericF1data == String(GenericF1s[3])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C4); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C4)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103C4)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
  


               }
               if(GenericF1data == String(GenericF1s[4])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R4); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R4)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R4)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
  

               }

               if(GenericF1data == String(GenericF1s[5])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R6); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R6)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R6)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          


               }
               if(GenericF1data == String(GenericF1s[6])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R8); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R8)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103R8)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          


               }
               if(GenericF1data == String(GenericF1s[7])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RC); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RC)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RC)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[8])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RD); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RD)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RD)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[9])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RE)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[10])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RF); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RF)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RF)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[11])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RG)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103RG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[12])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T4); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T4)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T4)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[13])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T6); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T6)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103T6)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[14])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103TB); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103TB)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103TB)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[15])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103V8); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103V8)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103V8)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[16])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VB); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VB)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[3].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VB)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[17])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VC); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VC)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VC)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[18])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VD); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VD)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VD)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[19])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VE)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[20])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VF); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VF)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VF)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[21])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VG)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103VG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[22])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZC); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZC)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZC)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[23])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZD); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZD)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZD)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[24])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZE)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[25])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZF); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZF)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZF)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[26])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZG)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }
               if(GenericF1data == String(GenericF1s[27])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZET6); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZET6)); //Alert the spec  
                    comvis.push([String(GenericF1data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[4].mcufamily.descriptionsspec.STM32F103ZET6)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                          
               }



            });  
         }
         if(String(mculistdata) == 'Generic STM32F4 Series'){
              console.log("Selected Generic STM32F4 Series"); //Display the selected option 
              var f85 = f19.add(microControl,'GenericF4list',["STM32F407ZG","STM32F407VGT","STM32F407VET","STM32F401CC","STM32F401RCT6","STM32F446RE","STM32F446RC","STM32F423RH","STM32F423CH","STM32F417VG","STM32F417VE","STM32F415RG","STM32F413RH","STM32F413RG","STM32F413CH","STM32F413CG","STM32F412RG","STM32F412RE","STM32F412CG","STM32F412CE","STM32F411RE","STM32F411RC","STM32F411CE","STM32F411CC","STM32F410RB","STM32F410R8","STM32F410CB","STM32F410C8","STM32F407VG","STM32F407VE","STM32F405RG","STM32F401RE","STM32F401RD","STM32F401RC","STM32F401RB","STM32F401CE"]).name("GenericF4"); //Generic F4 list data               
              var GenericF4s = ["STM32F407ZG","STM32F407VGT","STM32F407VET","STM32F401CC","STM32F401RCT6","STM32F446RE","STM32F446RC","STM32F423RH","STM32F423CH","STM32F417VG","STM32F417VE","STM32F415RG","STM32F413RH","STM32F413RG","STM32F413CH","STM32F413CG","STM32F412RG","STM32F412RE","STM32F412CG","STM32F412CE","STM32F411RE","STM32F411RC","STM32F411CE","STM32F411CC","STM32F410RB","STM32F410R8","STM32F410CB","STM32F410C8","STM32F407VG","STM32F407VE","STM32F405RG","STM32F401RE","STM32F401RD","STM32F401RC","STM32F401RB","STM32F401CE"];
              f85.onChange(function(value){
                  var GenericF4data = genericstm32F4.style.GenericF4list = value; // Get the value list of the GenericF4 microcontroller 
                  console.log(String(GenericF4data)); //Get the string list data of the microcontroller 
             if (GenericF4data == String(GenericF4s[0])){
                  
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407ZG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407ZG)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407ZG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   


             } 
            if (GenericF4data == String(GenericF4s[1])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VGT); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VGT)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VGT)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   

            }
            if(GenericF4data == String(GenericF4s[2])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VET); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VET)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VET)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   

            }
            if (GenericF4data == String(GenericF4s[3]))
            {
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CC); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CC)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CC)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
               
            }
            if (GenericF4data == String(GenericF4s[4])){

                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RCT6); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RCT6)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RCT6)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   

            
            
            }
            if (GenericF4data == String(GenericF4s[5])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RE)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[6])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RC); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RC)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F446RC)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[7])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423RH); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423RH)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423RH)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[6])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423CH); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423CH)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F423CH)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[7])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VG)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[8])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VE)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F417VE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[9])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F415RG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F415RG)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[4].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F415RG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[10])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RH); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RH)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RH)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }  
            if (GenericF4data == String(GenericF4s[11])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RG)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413RG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            } 
            if (GenericF4data == String(GenericF4s[12])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CH); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CH)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CH)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[13])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CG)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F413CG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[15])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RG)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[16])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RE)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412RE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[16])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CG)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[17])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CE)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F412CE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[18])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RE)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[19])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RC); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RC)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411RC)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[20])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CE)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[21])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CC); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CC)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F411CC)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[22])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410RB); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410RB)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410RB)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[23])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410R8); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410R8)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410R8)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[24])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410CB); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410CB)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410CB)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[25])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410C8); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410C8)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F410C8)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[26])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VG)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[27])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VE)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F407VE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[28])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F405RG); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F405RG)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F405RG)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[29])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RE)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[30])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RD); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RD)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RD)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[31])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RC); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RC)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RC)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[32])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RB); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RB)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401RB)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }
            if (GenericF4data == String(GenericF4s[33])){
                    var mcuRequest = new XMLHttpRequest(); //
                    mcuRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/MCUslist.json') // Get the Json data of the micro controller specification data structure
                    mcuRequest.onload = function() {
                    var mcuData = JSON.parse(mcuRequest.responseText); // Get the mcu data from the json file request
                    console.log("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CE); // Microcontroller spec 
                    alert(String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CE)); //Alert the spec  
                    comvis.push([String(GenericF4data),String("Board:"+ mcuData[5].Boardseries + ","+"mcus Spec:"+"\t" + mcuData[5].mcufamily.descriptionsspec.STM32F401CE)]); 
               
                    };
                    mcuRequest.send() // Sending the request for the mcu data on the web to get the data from the github   
            }

         });
  
         }
      });     
     var  f20 = f6.addFolder('Actuators driver specification'); // Actuators motor driver ic and circuit forthe onboard bord design that will generate automaticly 
          var f72  = f20.add(actuatorDrive,'Motortype',['DC gear motor','BLDC gear motor','Stepper gear motor','DC-planetary gear','Stepper motor with planetary gear','BLDC with planetary gear motor','Linear DC motor','Linear BLDC motor','Linear stepper motor']).name("Motor-type") // Select the motor type specifications 
          f72.onChange(function(value){
             var Motortypedata = Motortype.style.actuatorDrive = value; // Get the data of the motor type for specification and calculate the size of the motor and power needed in the job automatically 
             console.log(String(Motortypedata)); // Get the motor type data to display in the console of the webbrowser
             var motortypelist = ['DC gear motor','BLDC gear motor','Stepper gear motor','DC-planetary gear','Stepper motor with planetary gear','BLDC with planetary gear motor','Linear DC motor','Linear BLDC motor','Linear stepper motor'];
             motortypelist.length-1; // Get all the number of the list in the function  
             var r; 
              // For loop for listing the function to check the selected list of the motor and request the database concern to the specification 
             for(r=0;r < motortypelist.length-1 ; r++)
             {
               if(String(motortypelist[r]) == String(Motortypedata))
               {
                  console.log("Choose" + "\t" +String(motortypelist[r]));
                   // Actuators drive function and capability of the driver for running high efficient motion control  
                  //var f75 = f20.add(actuatorDrive,'MotorDrive',['DC motor driver','BLDC motor driver','Stepper motor driver']).name("Motor driver");
                  //f75.onChange(function(value){
                  //var MotorDrivedata = Motordriver.style.actuatorDrive = value; // Get the data ofr the driver type of the motor 
                  var motortypelist = ['DC motor driver','BLDC motor driver','Stepper motor driver']; // Motor type list for the motor driver type selection 
                  var motortypelenght = motortypelist.length -1;  // Get the lenght of the motor list then compare to the  
                   // Getting the motor driver upto the specification input from the database in the php                    
                  comvis.push(["Actuators-type",String(motortypelist)]); // Get the motor type list data                   
                  
               }          

             }

          });
          //Feedback sensor type for each actuator feed back function  
          var f73 = f20.add(actuatorDrive,'Sensorfeedback',['Disc encoder','Magnetic encoder','Analog potentiometer']).name("Feedback-Sensors"); // Get the sensor type that suitable with the actuators  
          f73.onChange(function(value){
              var Feedbacksensordata = Feedbacksensors.style.actuatorDrive = value; // Get the feedback data value of the sensors 
              console.log(String(Feedbacksensordata)); //Get the Feedback sensor data 
              // Sensor feed back data get this from the catalog specification and put into the json file data  
            if(Feedbacksensordata == "Disc encoder"){
              var FeedbackRequest = new XMLHttpRequest(); //
              FeedbackRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/Feedbacksense.json') // Get the Json data of the micro controller specification data structure
              FeedbackRequest.onload = function() {
              var FeedSenseData = JSON.parse(FeedbackRequest.responseText); // Get the mcu data from the json file request
              console.log("Sensor type:"+ FeedSenseData[0].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[0].Sensorlist.Sensorcode[0]+","+"Sensor details:"+"\t"+ FeedSenseData[0].Sensorlist.Sensordesc[0]); // Feed back sensor spec
              alert(String("Sensor type:"+ FeedSenseData[0].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[0].Sensorlist.Sensorcode[0]+","+"Sensor details:"+"\t"+ FeedSenseData[0].Sensorlist.Sensordesc[0])); //Alert the spec    
              comvis.push(["Actuator-Feedback-sensors",String("Sensor type:"+ FeedSenseData[0].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[0].Sensorlist.Sensorcode[0]+","+"Sensor details:"+"\t"+ FeedSenseData[0].Sensorlist.Sensordesc[0])]);
              console.log("Actuator-Feedback-sensors",String("Sensor type:"+ FeedSenseData[0].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[0].Sensorlist.Sensorcode[0]+","+"Sensor details:"+"\t"+ FeedSenseData[0].Sensorlist.Sensordesc[0]));
            };
              // Feedback request sensor function 
              FeedbackRequest.send() // Sending the request for the mcu data on the web to get the data from the github                                  
            } 
            if(Feedbacksensordata == "Magnetic encoder"){          
              var FeedbackRequest = new XMLHttpRequest(); //
              FeedbackRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/Feedbacksense.json') // Get the Json data of the micro controller specification data structure
              FeedbackRequest.onload = function() {
              var FeedSenseData = JSON.parse(FeedbackRequest.responseText); // Get the mcu data from the json file request
              console.log("Sensor type:"+ FeedSenseData[1].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[1].Sensorlist.Sensorcode[0]+','+"Sensor details:"+"\t"+ FeedSenseData[1].Sensorlist.Sensordesc[0]); // Feedback spec 
              alert(String("Sensor type:"+ FeedSenseData[1].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[1].Sensorlist.Sensorcode[0]+','+"Sensor details:"+"\t"+ FeedSenseData[1].Sensorlist.Sensordesc[0])); //Alert the spec          
              comvis.push(["Actuator-Feedback-sensors",String("Sensor type:"+ FeedSenseData[1].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[1].Sensorlist.Sensorcode[0]+','+"Sensor details:"+"\t"+ FeedSenseData[1].Sensorlist.Sensordesc[0])]);
              console.log("Actuator-Feedback-sensors",String("Sensor type:"+ FeedSenseData[1].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[1].Sensorlist.Sensorcode[0]+','+"Sensor details:"+"\t"+ FeedSenseData[1].Sensorlist.Sensordesc[0]));
            };
              // Feedback request sensor function 
              FeedbackRequest.send() // Sending the request for the mcu data on the web to get the data from the github                     
            }
            if(Feedbacksensordata == "Analog potentiometer")
            {
               var FeedbackRequest = new XMLHttpRequest(); //
              FeedbackRequest.open('GET','https://raw.githubusercontent.com/KornbotDevUltimatorKraton/KornbotDevUltimatorKraton.github.io/master/Feedbacksense.json') // Get the Json data of the micro controller specification data structure
              FeedbackRequest.onload = function() {
              var FeedSenseData = JSON.parse(FeedbackRequest.responseText); // Get the mcu data from the json file request
              console.log("Sensor type:"+ FeedSenseData[2].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[2].Sensorlist.Sensorcode[0]+","+"Sensor details:"+"\t"+ FeedSenseData[2].Sensorlist.Sensordesc[0]); // Feedvack spec 
              alert(String("Sensor type:"+ FeedSenseData[2].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[2].Sensorlist.Sensorcode[0]+","+"Sensor details:"+"\t"+ FeedSenseData[2].Sensorlist.Sensordesc[0])); //Alert the spec          
              comvis.push(["Actuator-Feedback-sensors",String("Sensor type:"+ FeedSenseData[2].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[2].Sensorlist.Sensorcode[0]+","+"Sensor details:"+"\t"+ FeedSenseData[2].Sensorlist.Sensordesc[0])]);
              console.log("Actuator-Feedback-sensors",String("Sensor type:"+ FeedSenseData[2].Sensortype + ","+" Sensor code:"+"\t" + FeedSenseData[2].Sensorlist.Sensorcode[0]+","+"Sensor details:"+"\t"+ FeedSenseData[2].Sensorlist.Sensordesc[0]));
            };
              // Feedback request sensor function 
              FeedbackRequest.send() // Sending the request for the mcu data on the web to get the data from the github                    
            }

          });

         
     var  f21 = f6.addFolder('Navigation sensors specification'); // Navigation sensors specification 
         // var f74 = f21.add().name(""); //Navigation system function 
    
     var  f77 = f6.addFolder('Battery specification'); // Battery specification for the devices power source options 
         // Battery module specification calculation  
         console.log("Battery list hardware for the active devices");
         var f90 = f77.add(BatterylisAct, 'batterylistact',['ACE-X1500mAh4SLipoBattery','']); //Get the list of the data 
         f90.onChange(function(value){
              var batteriesList = batteries.style.BatterylisAct = value; // Get the values list of battery 
              console.log(batteriesList);  // Display the battery list this term of list will be update into the json file 
              // Running the battery list model matching for each data analytic method elements 
              var canvas = document.getElementById("renderCanvas"); // Get the canvas element
                     var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
                     var createScene = function(){
                     var scene = new BABYLON.Scene(engine); // Create scene 
                     var gravityVector = new BABYLON.Vector3(0,-9.81, 0);
                     var physicsPlugin = new BABYLON.CannonJSPlugin();
                      // Enable gravity into the scene 
                     scene.enablePhysics(gravityVector, physicsPlugin); // Enable the physics engine 
                     
                     //scene.useRightHandedSystem = true;  //user Right Hand System
                     camera = new BABYLON.ArcRotateCamera("camera", 4.712, 1.571, 2, BABYLON.Vector3.Zero(), scene);
                     camera.attachControl(scene.getEngine().getRenderingCanvas());
                     camera.minZ = 0.1;
                     camera.maxZ = 1000;
                     camera.lowerRadiusLimit = 0.1;
                     camera.upperRadiusLimit = 5;
                     camera.wheelPrecision = 100;
                     camera.attachControl(canvas, true);
                    
                     // Add the light to the scene 
                     var light1 = new BABYLON.HemisphericLight("light1",new BABYLON.Vector3(1,1,0), scene); // Adding the light into the scene 
                     var light2 = new BABYLON.PointLight("light2",new BABYLON.Vector3(0,1,1), scene); // Create the point light into the scene positioning  
                     // Create the schere to testing the mesh in the scene  
                     //var sphere = BABYLON.MeshBuilder.CreateSphere("sphere",{diameter:2},scene); // Get the sphere 
                     
                     BABYLON.SceneLoader.LoadAssetContainer("static/", String(batteriesList)+".gltf", scene, function (container) {
                         var meshes = container.meshes;
                         var materials = container.materials;
                         //var skeleton = skeletons[0];
                         var mesh = meshes[0];
                         console.log(meshes[0]);
                         //Container add all scene 
                         container.addAllToScene();
                     });
                     //var strData = JSON.stringify(transformNodes);
                     BABYLON.SceneLoader.ImportMesh("","static/" ,String(batteriesList)+".gltf", scene, function (meshes, particleSystems, skeletons) {
                        var model = meshes[0];  // Get the model Mesh part 
                        //console.log(String(model)); //Get the model data 
                        console.log(scene.rootNodes); // Get the rootNodes successfully to get the bone and mesh list 
                        console.log(scene.rootNodes.length); // Get the root nodes length from the function from the file
                        model.rotation.y = Math.PI*0.25; // Model mesh roation 
                        meshes.rotation = new BABYLON.Vector3(Math.PI/2, Math.PI/2, Math.PI/2);
                        
                        var t = 0;
                        var i; 
                        for(i = 0; i <= scene.rootNodes.length; i++){ 

                              console.log(scene.rootNodes[i].name);
                              if(String(scene.rootNodes[i].name) == '__root__')
                              {
                                  console.log("Found to root");
                                  console.log(scene.rootNodes[i]); 
                                  console.log(scene.transformNodes); // Get the node of the mesh list name to make the motion control part rotation manipulaiton 
                                  console.log(scene.addReflectionProbe);
                               
                              } 
                              for(r = 0 ; r < scene.transformNodes.length; r ++)
                                  {  
                                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                     // Reading the element of the GLTF Mesh model file for the motion control and analysis
                                       if(String(scene.transformNodes[r].name) == 'Camera'){ 
                                          console.log("Camera for perspective on the mesh model"); // Get the perspective mesh model 
                                          console.log("Get the camera scene"+scene.cameras);  // Get the camera data int the scene 
                                       }
                                        // Light for the environment optical control 
                                       if(String(scene.transformNodes[r].name) == 'Light'){
                                           console.log("Light for the environment optical element");
                                       }
                                       //console.log(scene.transformNodes[r].name);
                                       if(String(scene.transformNodes[r].name).split(".").length != 2 && String(scene.transformNodes[r].name) != 'Light' ){
                                          
                                           if(String(scene.transformNodes[r].name) != 'Camera' && String(scene.transformNodes[r].name) != 'Bone'){ 
                                              console.log("Mesh part name data" + "\t" + scene.transformNodes[r].name);  // Get the part name of the model 
                                             
                                             }
                                       }
                                       if(String(scene.transformNodes[r].name).split(".").length == 2){
                                          var s;  // Screate the variable for list of the part in the gltf file
                                          for(s = 0; s < String(scene.transformNodes[r].name).split(".").length ;s++)
                                          {
                                             if(String(scene.transformNodes[r].name).split(".")[s] == 'Bone'){
                                                 console.log(String(scene.transformNodes[r].name).split(".")[0] + "\t" +"bone Parts number" + String(scene.transformNodes[r].name).split(".")[1]); 
                                                 
                                                 //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                                                          //Get the mesh of the part name to running on the Application 
                                                  //NLP parts analysis part and positioning 
                                                 

                                                //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                                             }
                                          }
                                     }
                                    
                                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>                             
                                 }
                            
                                  var w; 
                                  for(w = 0 ; w < scene.meshes.length ;w++){
                                         console.log(String(scene.meshes[w])); 
                                         console.log(scene.meshes[w]['position']);
                                         console.log(typeof(scene.meshes[w]['position'])); // Get the type of variable  
                                         var f87 = f27.add(kinematicsalgo,'kinematicsjoint',scene.meshes[w]['position']).name(scene.meshes[w]['name']); //Get the kinematics listed control 
                                              f87.onChange(function(value){
                                                  var KineData = kinematics.style.kinematicsjoint = value; //Get the kinematics joint list parts 
                                                  console.log(String(KineData));// Get the value of the positioning data  
                                                  //Get the pisition of the model mesh for the body mesh name position 
                                                       
                                             
                                         });
                                   } 
                                   console.log(String(scene.materials));  // Get the materials from the mesh in the scene function 
                                   var q;
                                   for(q = 0; q <= scene.materials.length;q++){
                                   var f57 = f56.add(materialcontrol,'matprop',scene.materials[q]).name(scene.materials[q]['id']); //Density of the materials adjust from the daw input 
                                   f57.onChange(function(value){
                                   var Densitydata = densitys.style.matprop = value; 
                                   console.log(String(Densitydata)); // Density of materials data
                                   comvis.push(["Density-data",String(Densitydata)]); // Get the density data for the materials   
                                   //Get the material density read 
                                      
                                 });
                              }   
                       }  
                       
                     
                     }); // Loading the meshes file from the model and control the meshes motion control 
                     
                     return scene;
                       
                     }; // Part of the scene created  
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 
                    var scene = createScene(); // Calling the create scene function 
                    engine.runRenderLoop(function () {
                    scene.render(); 
                    });
                  
         }); 

     var  f78 = f6.addFolder('Cellular LTE module specification'); 
        // Cellular LTE module specification 
         
     var f7 = gui.addFolder('Code generator');   // Code generator function for the option selected in the robot
         
         var f22 = f7.addFolder('Computer Vision system');  // Vision system
             // Check box function detection for the robot robot to be able to detect the object and recognize the function on each 
             // Control the behevier and path of the product control
            var f41 = f22.add(Visionparameters,'objectdetect').name('Object detection');
            f41.onChange(function(value){
               obdetect.style.Objectdetect = this.Objectdetect ? "block" : "none"; // Get the logic data boolean function 
               if(this.Objectdetect = !this.Objectdetect)
                {
                  console.log("Selected Object detection"); //Display the functoin of the object detection function 
                  comvis.push(["Objectdetection","config-on"]); // Object detection computer vision on               
                }
               else{
                  console.log("Not slected Object detection"); // Display the not selection 
                  
               }
            }); //Objectdetection function
            var f42 = f22.add(Visionparameters,'objectrecognition').name('Objectrecognition');
            f42.onChange(function(value){
               obrecog.style.Objectrecog = this.Objectrecog ? "block" : "none"; // Get the logic data boolean function 
               if(this.Objectrecog = !this.Objectrecog)   
                {
                  console.log("Selected Object recognition"); //Display the functoin of the object detection function 
                  comvis.push(["Objectrecognition","config-on"]); // Object detection computer vision on               

                }
               else{
                  console.log("Not selected Object recognition"); // Display the not selection 
               }
            }); // Object recognition function
            var f43 = f22.add(Visionparameters,'facerecognition').name('Face recognition');
            f43.onChange(function(value){
               facerecog.style.Facerecog = this.Facerecog ? "block" : "none"; // Get the logic data boolean function 
               if(this.Facerecog = !this.Facerecog)
                {
                  console.log("Selected Face recognition"); //Display the functoin of the object detection function 
                  comvis.push(["Facerecognition","config-on"]); // Object detection computer vision on               

                }
               else{
                  console.log("Not slected Face recognition"); // Display the not selection 
               }
            }); // face recognition function
            var f44 = f22.add(Visionparameters,'posedetection').name('Pose detection'); 
            f44.onChange(function(value){
               posedetect.style.Posedetect = this.Posedetect ? "block" : "none"; // Get the logic data boolean function 
               if(this.Posedetect = !this.Posedetect)
                {
                  console.log("Selected Pose detection"); //Display the functoin of the object detection function 
                  comvis.push(["Posedetection","config-on"]); // Object detection computer vision on               

                }
               else{
                  console.log("Not slected Pose detection"); // Display the not selection 
               }
            }); // pose detection function 
            var f45 = f22.add(Visionparameters,'poserecognition').name('Pose recognition');
            f45.onChange(function(){
               poserecog.style.Poserecog = this.Poserecog ? "block" : "none"; // Get the logic data boolean function 
               if(this.Poserecog = !this.Poserecog)
                {
                  console.log("Selected Pose recognition"); //Display the functoin of the object detection function 
                  comvis.push(["Poserecognition","config-on"]); // Object detection computer vision on               
                  
               }
               else{
                  console.log("Not slected Pose recognition"); // Display the not selection 
                  // Kill the process link 
               }
            }); // pose recognition function 
                     
         
         var f23 = f7.addFolder('Navigation system'); // navigation control 
                 // Navigation algorithm code 
                 
         var f24 = f7.addFolder('Dynamic control system'); // Dynmic control system 
               // Dynamics algorithm code 
         var f25 = f7.addFolder('Mapping nodes ystem'); // Mapping system function
              // Mapping algorithm function 
         var f39 = f25.add(Serialfirmware,'add').name('Node-system'); // Serial communication firmware to control the GPIO hardware like actuator and get the data from sensors 


         var f27 = f7.addFolder('Actuators kinematic controls'); //Kinematic control function to control the actuator of the robotics testing animation with the data that get from above specifcation to running the test script
                // Algorithm for the control system on the kinematic positioning design control 

         var f33 = f7.addFolder('Speech synthesis'); // Computer speech synthesis function
              // Audio data and speech collection function for robotic  require speaker hardware on the robotics with the hardware comfiguretion on the platform of the SBC that using 
         var f34 = f7.addFolder('Speech recognition');//Speech 
              // Speech selection type example for using in the robotics product deployment 
         var f49 = f7.addFolder('Artificial Intelligence'); // Artificial intelligence fucntion selection for creating the Visual programming flow chart 
                 // Inside function linking with the Rete.js to connect with the 
                 
         //Generate the speech recogntion from your own model or using already have in python code 
         var f38 = f7.addFolder('Firmware for MCU devices onboard'); // Micro controler automaticly please choose your micro controller option
                // Serial firmware setting baudrate before upload the code 
                var f47 = f38.add(SerialBaudrate,'message',['1200 bps','2400 bps','4800 bps','9600 bps','19200 bps','57600 bps','115200 bps']).name("SerialBaudrate"); 
                      
                         // Sending the value from the option selection for the serial communication baud rate into the data base or json file for data to generated the code
                      f47.onChange(function(value)   
                      {
                          var serialrate  = div.style.message = value; // Get the baudrate value from the roll function selection options 
                          console.log(String(serialrate));  // Display the serial baudrate data into the console string
                          comvis.push(["Serial-baudrate",String(serialrate)]); // Get the serial baudrate into the json file export the code into the json form     
                    });
                //var f39 = f38.add(Serialfirmware,'add').name('Serialcommunicaitonfirmware'); // Serial communication firmware to control the GPIO hardware like actuator and get the data from sensors 
                         // Get the firmware serial data update function                                                                                       
                // Setting the CAN BUS before upload the code into the
                var f48 = f38.add(CANbusBaudrate,'message',['1 Mbit/s','125 kbit/s','250 kbit/s']).name("CAN-BUS serial"); //Display the baudrate channel for the hardware connection test  
                     
                      //Function of the CAN bus for the industrial communication 
                     f48.onChange(function(value){
                        var canbus = CAN.style.message = value; // Get the message data from the gui function of the canbus adjustment to use in the code generator function 
                        console.log(String(canbus)); //CAN BUS function for the industrial communication    
                        // Setting the serial interface for upload the firmware into the microcontroller
                        comvis.push(["CANBUS-baudrate",String(canbus)]); //Get get the canbus   
                     }); 
                     
                var f40 = f38.add(Canfirmware, 'add').name('CAN BUS communication firmware'); // CAN BUS communication firmware to control the GPIO hardware like actuator and get the data from sensors 
                   
         var f50 = f7.add(VisualPro,'add').name('Code generator'); // Generated visual programming function                 
  var f26 = gui.addFolder('Manufacturing parts');   // Manufacturing part files sending to the manufacturer or your machine 
         
         var f28  = f26.addFolder('Manufacturing the parts');  // Manufacturing the part of the            
                var f29 = f28.addFolder('Using your local machine');  // Using your own local machine to build 
                    var f30 = f29.addFolder('3D printer');  // setting the 3d printer to 3d print wirelessly or take the file 
                    var f80 = f30.add(ThreeDprinter,"add").name("3dp G-code gen"); // Get the G-code generator from the 3d printer file 
                    var f31 = f29.addFolder('Pick and place electronics components');  // pick and place machine for the Export into the G-code or the ssh export command to run the 3d printer wirelessly 
                    var f81 = f31.add(Pickandplacemachine,"add").name("PNP G-code gen"); // Get the G-code generator from the 3d printer file 
                    var f32 = f29.addFolder('Assembly line robotics'); // Assembly line robotics for assemply the parts for the products 
                    var f82 = f32.add(AssemblyArm,"add").name("AssemArm yaml gen"); 
           // Connecting to the online electronics store part ordering function             
         var f33 = f26.addFolder('Online Electronics components store');               // Connect to the other elecotrnics online store 
               //Connecting to the digikey for the online electronics store 
               var f34 = f33.add(digikey,'add').name('Digikey store');   
               
           // Connecting to the online manufacturer components store;     
         var f35 = f26.addFolder('Online PCB and SMT Manufacturer'); 
                  //list of the online manufacturer   
               var f36  = f35.add(jlcpcb, 'add').name('PCB manufacture 2 layers');  // PCB load pcb 
                     // Get the data from the user interface and put this on the ordering process transformation 
               var f37 =  f35.add(jlcsmt, 'add').name('PCB SMT manufacturing');// SMT function for manufacturing the complete pcb with electronics component order
                    // Get the data from the user interface and put this on the ordering processing manufacturing the complete SMT process 
         //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                             //Json stringify for the data exporter for using in the analysis for making the product  

                
};
</script>
<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</body>
</body>
</head>
<body>
   <form method="POST">
   <div id="Stats-output"> </div> <!--Showing the status output function of the frame rate -->
   <div id="Pyrat"> </div>  <!--Testing sending seccond data--> 
    <!--Seril communication function -->
    <div id="some"> </div>   <!--Get the text data out put to send to the NLP function of the button search algorithm-->
    <div id="CANb"> </div>  <!--Data of the canbus baud rate setting function-->
    <!--Physics analysis control parameters function-->
    <div id="terrainA"> </div>  <!--Terrain Data select and display into the system of the visualization 3d Threejs with orbitcontrol and the FBX loader function  -->
    <div id="terrainF"> </div>  <!--Terrain friction data  -->    
    <div id="terrainR"> </div>  <!--Terrain Roughness data -->
    <div id="gravity"> </div>  <!--Terrain gravity data--> 
    <div id="density"> </div> <!--Materials density data-->
    <div id="lightintenses"></div> <!--Light intensity data--> 
    <!--Materials light skin function-->
    <div id="lightmat"> </div> <!--the data for the light matterials-->
    <div id="densityMat"> </div>  <!--Density matterials data reading from the json file form the specification-->
    <div id="Colormat0"> </div> <!--Get the color0 material mixer-->
    <div id="Colormat1"> </div> <!--Get the color1 materials mixer-->
    <!--Code generator-->
    <div id="Obdetectsys"> </div> <!--Object detection function sending to the html code -->
    <div id="Obrecogsys"> </div> <!----> 
    <div id="Facrecogsys"> </div> <!---->
    <div id="Posedetectsys"> </div> <!---->
    <div id="Poserecogsys"></div> <!---->
    <div id="PCBlayer"> </div> <!--PCB layers data feedback-->
    <div id="PCBcolor"> </div> <!--PCB Color data selection and pcb sample-->
    <div id="PCBdisColor"> </div> <!--PCB display color function-->
    <div id="PCBmaterials"> </div> <!--PCB data for material materials -->
    <!---------------------------------------------------------------------------------------------------------------->
             <!--SBC data -->
    <div id="SBCspec"> </div> <!--SBC specification data for display the information and schematics manufacturing-->  
   <!----------------------------------------------------------------------------------------------------------------->
           <!--Get the data from the data base query by the transducer selector input-->
   <div id="Transducerselect"> </div> <!--Sensors type for the selection function of Transducer-->
   <!--Micro controller part list -->
   <div id="MCUserieslist"> </div> <!--MCU Series list--> 
   <div id="Neucleo144"> </div> <!--Neucleo 144 list -->
   <div id="Neucleo64"> </div> <!--Neucleo 64 list -->
   <div id="Neucleo32"> </div> <!--Neucleo 32 list -->
   <div id="GenericF1"> </div> <!--Generic F1 list-->
   <div id="GenericF4"> </div> <!--Generic F4 list--> 
   
   <!----------------------------------------------------------------------------------------------------------------->
       <!---Actuators type specification selection --> 
   <div id="motortype"> </div> <!--Motor type specification for the actuator-->    
   <div id="Feedbacksensors"></div>
   <div id="Statussensors"></div>
   <div id="Motordriver"></div>   
  <!--------------------------------------------------------------------------------------------------------------------->
                  <!--Project and part naming-->
  <div id="Projectnaming"></div>
  <div id="Parts"> </div>
 <!---------------------------------------------------------------------------------------------------------------------->
                      <!--Kinematics code generator for joints-->
 <div id="Kinematics"></div> 
 <!--Battery function-->
 <div id="battery"> </div>
 <!--Asset model list-->
 <div id="Asset"></div>
 <div id="my-gui-container"></div>   <!---Get the position control for the dat.gui.js--> 
<!-- <div id="my-guir-container"></div>-->
 <div id="Componentsdata"></div>
 <div id="Comdata"></div>
 <div id="Microset"></div>
 <div id="Microdatset"></div> 
 <div id="ICdat"></div>
 <div id="ICdatset"></div>
 <div id="funcdat"></div>
 <div id="funcdataset"></div>
 <div id="Imagedat"></div>
 <div id="Imagedatset"></div>
 <div id="Acousdat"></div>
 <div id="Acousdatset"></div>
 <div id="Sensedat"></div>
 <div id="Sensedatset"></div>
 <div id="Computedat"></div>
 <div id="Computedatset"></div>
 <div id="Navidat"></div>
 <div id="Navidatset"></div>
 <div id="Ampdat"></div>
 <div id="Ampdatset"></div>
 <div id="Materialsdat"></div>
 <div id="Materialsdataset"></div>
 <div id="Celludat"></div>
 <div id="Celludataset"></div>
 <div id="Batterydat"></div>
 <div id="Batterydatsetr"></div>
 <div id="BMSdat"></div>
 <div id="BMSdataset"></div>
 <div id="Neucle32"></div>
 <div id="Neucle64"></div>
 <div id="Neucle144"></div>
 <div id="GenericF0"></div>
 <div id="GenericF1"></div>
 <div id="GenericF3"></div>
 <div id="GenericF4"></div>
 <div id="Sensorpartdat"></div>
 <div id="SensorSpecspart"></div>
 <div id="Sensorpinscom"></div>
</form>
   <!-----------------------------------------------------------------------------------------------------------------> 
   <script>
   document.getElementById("Transducerselect").value;
   </script>
  </body>
</html>
